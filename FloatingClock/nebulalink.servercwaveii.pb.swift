// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/nebulalink.servercwaveii.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///注册帧(Register Frame)
struct NebulalinkProMessage_RegisterFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///单元类型	
  var elementType: Int32 = 0

  ///名称
  var name: Data = Data()

  ///权限设置
  var setPermissionValue: [NebulalinkProMessage_RegisterFrame.SetPermission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SetPermission {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///权限类型
    var type: Int32 = 0

    ///权限级别	
    var level: Int32 = 0

    ///上传间隔
    var timeInterval: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///请求数据帧(Request Frame)
struct NebulalinkProMessage_RequestFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///单元类型
  var elementType: Int32 = 0

  ///请求数据类型
  var type: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///应答数据帧(Response Frame)
struct NebulalinkProMessage_ResponseFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///单元类型
  var elementType: Int32 = 0

  ///应答数据类型
  var type: Int32 = 0

  ///通信记录信息
  var communicationRecordValue: [NebulalinkProMessage_ResponseFrame.CommunicationRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CommunicationRecord {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///通信消息类型
    var msgType: Int32 = 0

    ///发送数据包数量
    var sendCount: Int32 = 0

    ///发送数据总长度
    var sendTotalByte: Int32 = 0

    ///接收数据包数量
    var recvCount: Int32 = 0

    ///接收数据总长度
    var recvTotalCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///自身信息(Host Info)
struct NebulalinkProMessage_HostInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///经度
  var longitude: Double = 0

  ///纬度
  var latitude: Double = 0

  ///海拔
  var altitude: Double = 0

  ///设备类型
  var deviceType: Int32 = 0

  ///自身OBU repeated count为0或1
  var hostObuValue: [NebulalinkProMessage_HostInfo.HostObu] = []

  ///自身RSU repeated count为0或1
  var hostRsuValue: [NebulalinkProMessage_HostInfo.HostRsu] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct HostObu {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///设备ID
    var deviceID: Data {
      get {return _storage._deviceID}
      set {_uniqueStorage()._deviceID = newValue}
    }

    var expandInformation: Data {
      get {return _storage._expandInformation}
      set {_uniqueStorage()._expandInformation = newValue}
    }

    ///车辆信息
    var plateNum: Data {
      get {return _storage._plateNum}
      set {_uniqueStorage()._plateNum = newValue}
    }

    ///车辆类型
    var vehicleClass: Int32 {
      get {return _storage._vehicleClass}
      set {_uniqueStorage()._vehicleClass = newValue}
    }

    ///燃料动力类型
    var fuelType: Int32 {
      get {return _storage._fuelType}
      set {_uniqueStorage()._fuelType = newValue}
    }

    ///车辆品牌型号
    var brandAndType: Data {
      get {return _storage._brandAndType}
      set {_uniqueStorage()._brandAndType = newValue}
    }

    ///车长
    var length: Float {
      get {return _storage._length}
      set {_uniqueStorage()._length = newValue}
    }

    ///车宽
    var width: Float {
      get {return _storage._width}
      set {_uniqueStorage()._width = newValue}
    }

    ///车高
    var height: Float {
      get {return _storage._height}
      set {_uniqueStorage()._height = newValue}
    }

    ///gps信息
    var speed: Float {
      get {return _storage._speed}
      set {_uniqueStorage()._speed = newValue}
    }

    ///速度方向
    var heading: Float {
      get {return _storage._heading}
      set {_uniqueStorage()._heading = newValue}
    }

    ///加速度
    var accel: Float {
      get {return _storage._accel}
      set {_uniqueStorage()._accel = newValue}
    }

    ///加速度方向
    var accelAngle: Float {
      get {return _storage._accelAngle}
      set {_uniqueStorage()._accelAngle = newValue}
    }

    ///定位时间
    var time: Int64 {
      get {return _storage._time}
      set {_uniqueStorage()._time = newValue}
    }

    ///定位状态
    var positioningState: Int32 {
      get {return _storage._positioningState}
      set {_uniqueStorage()._positioningState = newValue}
    }

    ///定位卫星数
    var satelliteNumber: Int32 {
      get {return _storage._satelliteNumber}
      set {_uniqueStorage()._satelliteNumber = newValue}
    }

    ///精度
    var precision: Float {
      get {return _storage._precision}
      set {_uniqueStorage()._precision = newValue}
    }

    ///can信息
    var transmissionStateSource: Int32 {
      get {return _storage._transmissionStateSource}
      set {_uniqueStorage()._transmissionStateSource = newValue}
    }

    ///档位
    var transmissionState: Int32 {
      get {return _storage._transmissionState}
      set {_uniqueStorage()._transmissionState = newValue}
    }

    ///can车速有效性
    var speedCanValid: Int32 {
      get {return _storage._speedCanValid}
      set {_uniqueStorage()._speedCanValid = newValue}
    }

    ///can车速
    var speedCan: Float {
      get {return _storage._speedCan}
      set {_uniqueStorage()._speedCan = newValue}
    }

    ///can车速方向有效性
    var headingCanSpeed: Int32 {
      get {return _storage._headingCanSpeed}
      set {_uniqueStorage()._headingCanSpeed = newValue}
    }

    ///can车速方向
    var headingCan: Float {
      get {return _storage._headingCan}
      set {_uniqueStorage()._headingCan = newValue}
    }

    ///方向盘转角有效性
    var steeringWheelAngleValid: Int32 {
      get {return _storage._steeringWheelAngleValid}
      set {_uniqueStorage()._steeringWheelAngleValid = newValue}
    }

    ///方向盘转角	
    var steeringWheelAngle: Float {
      get {return _storage._steeringWheelAngle}
      set {_uniqueStorage()._steeringWheelAngle = newValue}
    }

    ///传感器加速度有效性
    var acc4WayValid: Int32 {
      get {return _storage._acc4WayValid}
      set {_uniqueStorage()._acc4WayValid = newValue}
    }

    ///纵向加速度
    var acc4WayLon: Float {
      get {return _storage._acc4WayLon}
      set {_uniqueStorage()._acc4WayLon = newValue}
    }

    ///横向加速度
    var acc4WayLat: Float {
      get {return _storage._acc4WayLat}
      set {_uniqueStorage()._acc4WayLat = newValue}
    }

    ///垂直加速度
    var acc4WayVert: Float {
      get {return _storage._acc4WayVert}
      set {_uniqueStorage()._acc4WayVert = newValue}
    }

    ///角加速度
    var acc4WayYaw: Float {
      get {return _storage._acc4WayYaw}
      set {_uniqueStorage()._acc4WayYaw = newValue}
    }

    ///控制信息
    var brakeStateValid: Int32 {
      get {return _storage._brakeStateValid}
      set {_uniqueStorage()._brakeStateValid = newValue}
    }

    ///制动踏板状态
    var brakePedalState: Int32 {
      get {return _storage._brakePedalState}
      set {_uniqueStorage()._brakePedalState = newValue}
    }

    ///制动器状态
    var brakeAppliedState: Int32 {
      get {return _storage._brakeAppliedState}
      set {_uniqueStorage()._brakeAppliedState = newValue}
    }

    ///TractionControl系统状态
    var tractionControlState: Int32 {
      get {return _storage._tractionControlState}
      set {_uniqueStorage()._tractionControlState = newValue}
    }

    ///防抱死系统状态
    var absState: Int32 {
      get {return _storage._absState}
      set {_uniqueStorage()._absState = newValue}
    }

    ///StabilityControl系统状态
    var stabilityControlState: Int32 {
      get {return _storage._stabilityControlState}
      set {_uniqueStorage()._stabilityControlState = newValue}
    }

    ///BrakeBoostApplied
    var brakeBoostApplied: Int32 {
      get {return _storage._brakeBoostApplied}
      set {_uniqueStorage()._brakeBoostApplied = newValue}
    }

    ///AuxiliaryBrakeStatus
    var auxiliaryBrakeState: Int32 {
      get {return _storage._auxiliaryBrakeState}
      set {_uniqueStorage()._auxiliaryBrakeState = newValue}
    }

    ///车辆事件标志来源
    var vehicleEventFlagSource: Int32 {
      get {return _storage._vehicleEventFlagSource}
      set {_uniqueStorage()._vehicleEventFlagSource = newValue}
    }

    ///车辆事件标志
    var vehicleEventFlag: Int32 {
      get {return _storage._vehicleEventFlag}
      set {_uniqueStorage()._vehicleEventFlag = newValue}
    }

    ///车辆灯光来源
    var vehicleLightsStateSource: Int32 {
      get {return _storage._vehicleLightsStateSource}
      set {_uniqueStorage()._vehicleLightsStateSource = newValue}
    }

    ///车辆灯光状态
    var vehicleLightsState: Int32 {
      get {return _storage._vehicleLightsState}
      set {_uniqueStorage()._vehicleLightsState = newValue}
    }

    ///制动踏板深度有效性
    var brakePedalDepthSource: Int32 {
      get {return _storage._brakePedalDepthSource}
      set {_uniqueStorage()._brakePedalDepthSource = newValue}
    }

    ///制动踏板深度
    var brakePedalDepth: Float {
      get {return _storage._brakePedalDepth}
      set {_uniqueStorage()._brakePedalDepth = newValue}
    }

    ///地图历史路径信息
    var mapInformationValue: [NebulalinkProMessage_HostInfo.HostObu.MapInformation] {
      get {return _storage._mapInformationValue}
      set {_uniqueStorage()._mapInformationValue = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct MapInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///路径点经度					
      var pointLongitude: Double = 0

      ///路径点纬度
      var pointLatitude: Double = 0

      ///路径点海拔
      var pointAltitude: Double = 0

      ///路径点速度
      var pointSpeed: Float = 0

      ///路径点方向
      var pointHeading: Float = 0

      ///路径点定位时间
      var pointTime: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct HostRsu {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///版本信息
    var version: Int32 = 0

    ///设备ID
    var deviceID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///非自身OBU(Other Obu)
struct NebulalinkProMessage_OtherObu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///非自身OBU信息
  var otherObuInfoValue: [NebulalinkProMessage_OtherObu.OtherObuInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OtherObuInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///本地ID
    var localID: Int32 {
      get {return _storage._localID}
      set {_uniqueStorage()._localID = newValue}
    }

    ///设备ID
    var deviceID: Data {
      get {return _storage._deviceID}
      set {_uniqueStorage()._deviceID = newValue}
    }

    ///车辆信息
    var plateNum: Data {
      get {return _storage._plateNum}
      set {_uniqueStorage()._plateNum = newValue}
    }

    ///车辆类型
    var vehicleClass: Int32 {
      get {return _storage._vehicleClass}
      set {_uniqueStorage()._vehicleClass = newValue}
    }

    ///燃料动力类型
    var fuelType: Int32 {
      get {return _storage._fuelType}
      set {_uniqueStorage()._fuelType = newValue}
    }

    ///车辆品牌型号
    var brandAndType: Data {
      get {return _storage._brandAndType}
      set {_uniqueStorage()._brandAndType = newValue}
    }

    ///车长
    var length: Float {
      get {return _storage._length}
      set {_uniqueStorage()._length = newValue}
    }

    ///车宽
    var width: Float {
      get {return _storage._width}
      set {_uniqueStorage()._width = newValue}
    }

    ///车高
    var height: Float {
      get {return _storage._height}
      set {_uniqueStorage()._height = newValue}
    }

    ///gps信息	
    var longitude: Double {
      get {return _storage._longitude}
      set {_uniqueStorage()._longitude = newValue}
    }

    ///纬度
    var latitude: Double {
      get {return _storage._latitude}
      set {_uniqueStorage()._latitude = newValue}
    }

    ///海拔
    var altitude: Double {
      get {return _storage._altitude}
      set {_uniqueStorage()._altitude = newValue}
    }

    ///速度
    var speed: Float {
      get {return _storage._speed}
      set {_uniqueStorage()._speed = newValue}
    }

    ///速度方向
    var heading: Float {
      get {return _storage._heading}
      set {_uniqueStorage()._heading = newValue}
    }

    ///加速度
    var accel: Float {
      get {return _storage._accel}
      set {_uniqueStorage()._accel = newValue}
    }

    ///加速度方向
    var accelAngle: Float {
      get {return _storage._accelAngle}
      set {_uniqueStorage()._accelAngle = newValue}
    }

    ///定位时间
    var time: Int64 {
      get {return _storage._time}
      set {_uniqueStorage()._time = newValue}
    }

    ///can信息
    var transmissionStateSource: Int32 {
      get {return _storage._transmissionStateSource}
      set {_uniqueStorage()._transmissionStateSource = newValue}
    }

    ///档位
    var transmissionState: Int32 {
      get {return _storage._transmissionState}
      set {_uniqueStorage()._transmissionState = newValue}
    }

    ///can车速有效性
    var speedCanValid: Int32 {
      get {return _storage._speedCanValid}
      set {_uniqueStorage()._speedCanValid = newValue}
    }

    ///can车速
    var speedCan: Float {
      get {return _storage._speedCan}
      set {_uniqueStorage()._speedCan = newValue}
    }

    ///can车速方向有效性
    var headingCanSpeed: Int32 {
      get {return _storage._headingCanSpeed}
      set {_uniqueStorage()._headingCanSpeed = newValue}
    }

    ///can车速方向
    var headingCan: Float {
      get {return _storage._headingCan}
      set {_uniqueStorage()._headingCan = newValue}
    }

    ///方向盘转角有效性
    var steeringWheelAngleValid: Int32 {
      get {return _storage._steeringWheelAngleValid}
      set {_uniqueStorage()._steeringWheelAngleValid = newValue}
    }

    ///方向盘转角	
    var steeringWheelAngle: Float {
      get {return _storage._steeringWheelAngle}
      set {_uniqueStorage()._steeringWheelAngle = newValue}
    }

    ///传感器加速度有效性
    var acc4WayValid: Int32 {
      get {return _storage._acc4WayValid}
      set {_uniqueStorage()._acc4WayValid = newValue}
    }

    ///纵向加速度
    var acc4WayLon: Float {
      get {return _storage._acc4WayLon}
      set {_uniqueStorage()._acc4WayLon = newValue}
    }

    ///横向加速度
    var acc4WayLat: Float {
      get {return _storage._acc4WayLat}
      set {_uniqueStorage()._acc4WayLat = newValue}
    }

    ///垂直加速度
    var acc4WayVert: Float {
      get {return _storage._acc4WayVert}
      set {_uniqueStorage()._acc4WayVert = newValue}
    }

    ///角加速度
    var acc4WayYaw: Float {
      get {return _storage._acc4WayYaw}
      set {_uniqueStorage()._acc4WayYaw = newValue}
    }

    ///控制信息
    var brakeStateValid: Int32 {
      get {return _storage._brakeStateValid}
      set {_uniqueStorage()._brakeStateValid = newValue}
    }

    ///制动踏板状态
    var brakePedalState: Int32 {
      get {return _storage._brakePedalState}
      set {_uniqueStorage()._brakePedalState = newValue}
    }

    ///制动器状态
    var brakeAppliedState: Int32 {
      get {return _storage._brakeAppliedState}
      set {_uniqueStorage()._brakeAppliedState = newValue}
    }

    ///TractionControl系统状态
    var tractionControlState: Int32 {
      get {return _storage._tractionControlState}
      set {_uniqueStorage()._tractionControlState = newValue}
    }

    ///防抱死系统状态
    var absState: Int32 {
      get {return _storage._absState}
      set {_uniqueStorage()._absState = newValue}
    }

    ///StabilityControl系统状态
    var stabilityControlState: Int32 {
      get {return _storage._stabilityControlState}
      set {_uniqueStorage()._stabilityControlState = newValue}
    }

    ///BrakeBoostApplied
    var brakeBoostApplied: Int32 {
      get {return _storage._brakeBoostApplied}
      set {_uniqueStorage()._brakeBoostApplied = newValue}
    }

    ///AuxiliaryBrakeStatus
    var auxiliaryBrakeState: Int32 {
      get {return _storage._auxiliaryBrakeState}
      set {_uniqueStorage()._auxiliaryBrakeState = newValue}
    }

    ///车辆事件标志来源
    var vehicleEventFlagSource: Int32 {
      get {return _storage._vehicleEventFlagSource}
      set {_uniqueStorage()._vehicleEventFlagSource = newValue}
    }

    ///车辆事件标志
    var vehicleEventFlag: Int32 {
      get {return _storage._vehicleEventFlag}
      set {_uniqueStorage()._vehicleEventFlag = newValue}
    }

    ///车辆灯光状态
    var vehicleLightsState: Int32 {
      get {return _storage._vehicleLightsState}
      set {_uniqueStorage()._vehicleLightsState = newValue}
    }

    ///制动踏板深度有效性
    var brakePedalDepthSource: Int32 {
      get {return _storage._brakePedalDepthSource}
      set {_uniqueStorage()._brakePedalDepthSource = newValue}
    }

    ///制动踏板深度
    var brakePedalDepth: Float {
      get {return _storage._brakePedalDepth}
      set {_uniqueStorage()._brakePedalDepth = newValue}
    }

    ///地图历史路径信息
    var mapInformationValue: [NebulalinkProMessage_OtherObu.OtherObuInfo.MapInformation] {
      get {return _storage._mapInformationValue}
      set {_uniqueStorage()._mapInformationValue = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct MapInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///路径点经度					
      var pointLongitude: Double = 0

      ///路径点纬度
      var pointLatitude: Double = 0

      ///路径点海拔
      var pointAltitude: Double = 0

      ///路径点速度
      var pointSpeed: Float = 0

      ///路径点方向
      var pointHeading: Float = 0

      ///路径点定位时间
      var pointTime: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

///非自身RSU(Other Rsu)
struct NebulalinkProMessage_OtherRsu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///非自身RSU信息
  var otherRsuInfoValue: [NebulalinkProMessage_OtherRsu.OtherRsuInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OtherRsuInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///本地ID
    var localID: Int32 = 0

    ///版本信息
    var version: Int32 = 0

    ///设备ID
    var deviceID: Data = Data()

    ///gps信息
    var longitude: Double = 0

    ///纬度
    var latitude: Double = 0

    ///海拔
    var altitude: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///路侧交通参与者信息：机动车(PTV)
struct NebulalinkProMessage_PTV {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///PTV信息
  var ptvInfomationValue: [NebulalinkProMessage_PTV.PtvInfomation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PtvInfomation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///ID
    var id: Int32 {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    ///对象来源
    var sourceType: Int32 {
      get {return _storage._sourceType}
      set {_uniqueStorage()._sourceType = newValue}
    }

    ///对象来源ID
    var sourceID: Data {
      get {return _storage._sourceID}
      set {_uniqueStorage()._sourceID = newValue}
    }

    ///设备ID
    var deviceID: Data {
      get {return _storage._deviceID}
      set {_uniqueStorage()._deviceID = newValue}
    }

    ///车辆信息
    var plateNum: Data {
      get {return _storage._plateNum}
      set {_uniqueStorage()._plateNum = newValue}
    }

    ///车辆类型
    var vehicleClass: Int32 {
      get {return _storage._vehicleClass}
      set {_uniqueStorage()._vehicleClass = newValue}
    }

    ///燃料动力类型
    var fuelType: Int32 {
      get {return _storage._fuelType}
      set {_uniqueStorage()._fuelType = newValue}
    }

    ///车辆品牌型号
    var brandAndType: Data {
      get {return _storage._brandAndType}
      set {_uniqueStorage()._brandAndType = newValue}
    }

    ///长
    var length: Float {
      get {return _storage._length}
      set {_uniqueStorage()._length = newValue}
    }

    ///宽
    var width: Float {
      get {return _storage._width}
      set {_uniqueStorage()._width = newValue}
    }

    ///高
    var height: Float {
      get {return _storage._height}
      set {_uniqueStorage()._height = newValue}
    }

    ///gps信息
    var longitude: Double {
      get {return _storage._longitude}
      set {_uniqueStorage()._longitude = newValue}
    }

    ///纬度
    var latitude: Double {
      get {return _storage._latitude}
      set {_uniqueStorage()._latitude = newValue}
    }

    ///海拔
    var altitude: Double {
      get {return _storage._altitude}
      set {_uniqueStorage()._altitude = newValue}
    }

    ///速度
    var speed: Float {
      get {return _storage._speed}
      set {_uniqueStorage()._speed = newValue}
    }

    ///速度方向
    var heading: Float {
      get {return _storage._heading}
      set {_uniqueStorage()._heading = newValue}
    }

    ///加速度
    var accel: Float {
      get {return _storage._accel}
      set {_uniqueStorage()._accel = newValue}
    }

    ///加速度方向
    var accelAngle: Float {
      get {return _storage._accelAngle}
      set {_uniqueStorage()._accelAngle = newValue}
    }

    ///定位时间
    var time: Int64 {
      get {return _storage._time}
      set {_uniqueStorage()._time = newValue}
    }

    ///精度
    var precision: Float {
      get {return _storage._precision}
      set {_uniqueStorage()._precision = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

///路侧交通参与者信息：非机动车(PNV)
struct NebulalinkProMessage_PNV {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///PNV信息
  var pnvInfomationValue: [NebulalinkProMessage_PNV.PnvInfomation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PnvInfomation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///单元类型
    var type: Int32 = 0

    ///ID
    var id: Int32 = 0

    ///对象来源
    var sourceType: Int32 = 0

    ///对象来源ID
    var sourceID: Data = Data()

    ///设备ID
    var deviceID: Data = Data()

    ///gps信息
    var longitude: Double = 0

    ///纬度
    var latitude: Double = 0

    ///海拔
    var altitude: Double = 0

    ///速度
    var speed: Float = 0

    ///速度方向
    var heading: Float = 0

    ///加速度
    var accel: Float = 0

    ///加速度方向
    var accelAngle: Float = 0

    ///定位时间
    var time: Int64 = 0

    ///精度	
    var precision: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///逻辑地图(Logical Map)
struct NebulalinkProMessage_LogicalMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///时间戳
  var time: Int64 = 0

  ///地图节点
  var mapNodeValue: [NebulalinkProMessage_LogicalMap.MapNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MapNode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///经度
    var longitude: Double = 0

    ///纬度
    var latitude: Double = 0

    ///海拔
    var altitude: Double = 0

    ///名称
    var name: Data = Data()

    ///节点ID
    var nodeID: Int64 = 0

    ///地图节点包含的路段信息
    var nodeLinkValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct NodeLink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///上游节点
      var upstrNodeID: Int64 = 0

      ///名称
      var name: Data = Data()

      ///车道宽度
      var laneWidth: Float = 0

      ///路段限速
      var linkSpeedLimitsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkSpeedLimits] = []

      ///路段位置点
      var linkPointsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkPoints] = []

      ///路段连接关系
      var linkMovementsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkMovements] = []

      ///路段包含的车道信息
      var linkLanesValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct LinkSpeedLimits {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///限速类型
        var speedLimitType: Int32 = 0

        ///速度限制m/s
        var speed: Float = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct LinkPoints {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///经度
        var longitude: Double = 0

        ///纬度
        var latitude: Double = 0

        ///海拔
        var altitude: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct LinkMovements {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///区域号
        var roadRegulatorID: Int32 = 0

        ///节点号
        var nodeID: Int32 = 0

        ///信号灯相位号
        var phaseID: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct LinkLanes {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///车道号
        var laneID: Int32 = 0

        ///车道宽度
        var laneWidth: Int32 = 0

        ///允许转向行为
        var allowedManeuvers: Int32 = 0

        ///共享车道
        var laneSharing: Int32 = 0

        ///车道类型
        var laneAttributesType: Int32 = 0

        ///车道限速
        var laneSpeedLimitsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneSpeedLimits] = []

        ///车道连接信息
        var laneConnectionsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneConnections] = []

        ///车道的位置点
        var lanePointsValue: [NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LanePoints] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct LaneSpeedLimits {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          ///限速类型
          var speedLimitType: Int32 = 0

          ///速度限制m/s
          var speed: Float = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct LaneConnections {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          ///区域号
          var roadRegulatorID: Int32 = 0

          ///node_id
          var nodeID: Int32 = 0

          ///lane_id
          var laneID: Int32 = 0

          ///allowed_maneuvers
          var allowedManeuvers: Int32 = 0

          ///phase_id
          var phaseID: Int32 = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct LanePoints {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          ///经度
          var longitude: Double = 0

          ///纬度
          var latitude: Double = 0

          ///海拔
          var altitude: Double = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  init() {}
}

///道路交通标志信息(RTS)
struct NebulalinkProMessage_RTS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///道路交通标志数据
  var rtsDataValue: [NebulalinkProMessage_RTS.RtsData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RtsData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///标志编号
    var rtsID: Int32 = 0

    ///标志类型
    var rtsType: Int32 = 0

    ///标志经度
    var rtsLongitude: Double = 0

    ///标志纬度
    var rtsLatitude: Double = 0

    ///标志海拔
    var rtsAltitude: Double = 0

    ///标志描述
    var rtsDescription: Data = Data()

    ///标志起始时间
    var rtsStartTime: Int64 = 0

    ///标志结束时间
    var rtsEndTime: Int64 = 0

    ///标志优先级
    var rtsPriority: Int32 = 0

    ///所属路侧信息
    var rsuLongitude: Double = 0

    ///RSU纬度
    var rsuLatitude: Double = 0

    ///RSU海拔
    var rsuAltitude: Double = 0

    ///RSU时间戳
    var rsuTime: Int64 = 0

    ///RSU ID
    var rsuID: Data = Data()

    ///RTS关联路径信息
    var rtsPathInformationValue: [NebulalinkProMessage_RTS.RtsData.RtsPathInformation] = []

    ///RTS关联路段信息
    var rtsLinkInformationValue: [NebulalinkProMessage_RTS.RtsData.RtsLinkInformation] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct RtsPathInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///影响半径
      var pathRadius: Float = 0

      ///关联路径位置点
      var pathPointInformationValue: [NebulalinkProMessage_RTS.RtsData.RtsPathInformation.PathPointInformation] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct PathPointInformation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///位置点经度
        var pointLongitude: Double = 0

        ///位置点纬度
        var pointLatitude: Double = 0

        ///位置点海拔
        var pointAltitude: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct RtsLinkInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///上游节点区域号
      var upRegulatorID: Int32 = 0

      ///上游节点号
      var upNodeID: Int32 = 0

      ///下游节点区域号
      var downRegulatorID: Int32 = 0

      ///下游节点号
      var downNodeID: Int32 = 0

      ///关联车道
      var lanes: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

///道路交通事件信息(RTE)
struct NebulalinkProMessage_RTE {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///道路交通标志数据
  var rteDataValue: [NebulalinkProMessage_RTE.RteData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RteData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///事件编号
    var rteID: Int32 {
      get {return _storage._rteID}
      set {_uniqueStorage()._rteID = newValue}
    }

    ///事件类型
    var rteType: Int32 {
      get {return _storage._rteType}
      set {_uniqueStorage()._rteType = newValue}
    }

    ///事件源
    var rteSource: Int32 {
      get {return _storage._rteSource}
      set {_uniqueStorage()._rteSource = newValue}
    }

    ///事件经度
    var rteLongitude: Double {
      get {return _storage._rteLongitude}
      set {_uniqueStorage()._rteLongitude = newValue}
    }

    ///事件纬度
    var rteLatitude: Double {
      get {return _storage._rteLatitude}
      set {_uniqueStorage()._rteLatitude = newValue}
    }

    ///事件海拔
    var rteAltitude: Double {
      get {return _storage._rteAltitude}
      set {_uniqueStorage()._rteAltitude = newValue}
    }

    ///事件半径
    var rteRadius: Float {
      get {return _storage._rteRadius}
      set {_uniqueStorage()._rteRadius = newValue}
    }

    ///事件描述
    var rteDescription: Data {
      get {return _storage._rteDescription}
      set {_uniqueStorage()._rteDescription = newValue}
    }

    ///事件起始时间
    var rteStartTime: Int64 {
      get {return _storage._rteStartTime}
      set {_uniqueStorage()._rteStartTime = newValue}
    }

    ///事件结束时间
    var rteEndTime: Int64 {
      get {return _storage._rteEndTime}
      set {_uniqueStorage()._rteEndTime = newValue}
    }

    ///事件优先级		
    var rtePriority: Int32 {
      get {return _storage._rtePriority}
      set {_uniqueStorage()._rtePriority = newValue}
    }

    ///所属路侧信息
    var rsuLongitude: Double {
      get {return _storage._rsuLongitude}
      set {_uniqueStorage()._rsuLongitude = newValue}
    }

    ///RSU纬度
    var rsuLatitude: Double {
      get {return _storage._rsuLatitude}
      set {_uniqueStorage()._rsuLatitude = newValue}
    }

    ///RSU海拔
    var rsuAltitude: Double {
      get {return _storage._rsuAltitude}
      set {_uniqueStorage()._rsuAltitude = newValue}
    }

    ///RSU时间戳
    var rsuTime: Int64 {
      get {return _storage._rsuTime}
      set {_uniqueStorage()._rsuTime = newValue}
    }

    ///RSU ID
    var rsuID: Data {
      get {return _storage._rsuID}
      set {_uniqueStorage()._rsuID = newValue}
    }

    ///RTE关联路径信息
    var rtePathInformationValue: [NebulalinkProMessage_RTE.RteData.RtePathInformation] {
      get {return _storage._rtePathInformationValue}
      set {_uniqueStorage()._rtePathInformationValue = newValue}
    }

    ///RTE关联路段信息
    var rteLinkInformationValue: [NebulalinkProMessage_RTE.RteData.RteLinkInformation] {
      get {return _storage._rteLinkInformationValue}
      set {_uniqueStorage()._rteLinkInformationValue = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct RtePathInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///影响半径
      var pathRadius: Float = 0

      ///关联路径位置点
      var pathPointInformationValue: [NebulalinkProMessage_RTE.RteData.RtePathInformation.PathPointInformation] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct PathPointInformation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///位置点经度
        var pointLongitude: Double = 0

        ///位置点纬度
        var pointLatitude: Double = 0

        ///位置点海拔
        var pointAltitude: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct RteLinkInformation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///上游节点区域号
      var upRegulatorID: Int32 = 0

      ///上游节点号
      var upNodeID: Int32 = 0

      ///下游节点区域号
      var downRegulatorID: Int32 = 0

      ///下游节点号
      var downNodeID: Int32 = 0

      ///关联车道
      var lanes: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

///信号灯信息(Traffic Light)
struct NebulalinkProMessage_TrafficLight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///信号灯信息
  var trafficLightInformationValue: [NebulalinkProMessage_TrafficLight.TrafficLightInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TrafficLightInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///信号灯描述
    var description_p: Data = Data()

    ///信号灯所在路口
    var intersectionRegionNodeID: Int64 = 0

    ///信号灯状态
    var status: Int32 = 0

    ///时间戳
    var time: Int64 = 0

    ///时间置信度
    var timeConfidence: Int32 = 0

    ///信号灯相位
    var trafficLightPhaseValue: [NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TrafficLightPhase {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///相位ID
      var phaseID: Int32 = 0

      ///相位状态
      var phaseStatusValue: [NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase.PhaseStatus] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct PhaseStatus {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///灯色状态
        var lightStatus: Int32 = 0

        ///开始时间
        var startTime: Float = 0

        ///最小结束时间
        var minEndTime: Float = 0

        ///最大结束时间
        var maxEndTime: Float = 0

        ///结束时间
        var endTime: Float = 0

        ///结束时间置信度
        var timeConfidence: Int32 = 0

        ///下次开始时间
        var nextStartTime: Float = 0

        ///下一周期
        var nextCycle: Float = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  init() {}
}

///信号灯配时方案(Traffic Signal Plan)
struct NebulalinkProMessage_TrafficSignalPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///信号灯信息（用于TSP）
  var trafficSignalValue: [NebulalinkProMessage_TrafficSignalPlan.TrafficSignal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TrafficSignal {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///信号灯名称
    var signalName: Data = Data()

    ///信号灯所在路口
    var intersectionRegionNodeID: Int64 = 0

    ///时钟偏移
    var signalOffset: Float = 0

    ///同步时间
    var syncTime: Int32 = 0

    ///信号灯状态
    var status: Int32 = 0

    ///信号灯所在时区
    var timeZone: Int32 = 0

    ///信号灯配时方案
    var trafficSignalPlanInfoValue: [NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TrafficSignalPlanInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///方案描述
      var planName: Data = Data()

      ///方案id
      var planID: Int32 = 0

      ///方案开始时间
      var startTim: Int32 = 0

      ///方案结束时间
      var endTime: Int32 = 0

      ///方案周期长度
      var cycle: Float = 0

      ///时间偏移(offset)
      var offset: Float = 0

      ///参考相位1编号
      var referencePhase1: Int32 = 0

      ///参考相位2编号
      var referencePhase2: Int32 = 0

      ///参考相位3编号
      var referencePhase3: Int32 = 0

      ///参考相位4编号
      var referencePhase4: Int32 = 0

      ///偏移参考类型
      var referenceType: Data = Data()

      ///信号灯配时相位，其中所有数据和当前时间无关
      var trafficSignalPlanPhaseValue: [NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo.TrafficSignalPlanPhase] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct TrafficSignalPlanPhase {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        ///相位ID
        var phaseID: Int32 = 0

        ///相位本地起始点
        var localStart: Float = 0

        ///前导绿灯时长
        var preGreen: Float = 0

        ///相位绿灯时长
        var green: Float = 0

        ///相位最小绿灯时长
        var minGreen: Float = 0

        ///相位最大绿灯时长
        var maxGreen: Float = 0

        ///相位黄灯时长
        var yellow: Float = 0

        ///相位闪黄灯时长
        var yellowFlash: Float = 0

        ///相位全红灯时长
        var red: Float = 0

        ///相位闪红灯时长
        var redFlash: Float = 0

        ///行人绿灯时长
        var pedGreen: Float = 0

        ///行人绿闪时长
        var pedGreenFlash: Float = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  init() {}
}

///信号灯配时方案偏移部分(Traffic Signal Plan - Offset)
struct NebulalinkProMessage_TrafficSignalPlanOffset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///信号灯信息（用于TSP）- 内容与TSP数据相同，目的是更新signal_offset
  var trafficSignalValue: [NebulalinkProMessage_TrafficSignalPlanOffset.TrafficSignal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TrafficSignal {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///信号灯所在路口
    var intersectionRegionNodeID: Int64 = 0

    ///时钟偏移
    var signalOffset: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///预警目标(Warning Target)
struct NebulalinkProMessage_WarningTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///预警目标处理结果信息
  var warningResultValue: [NebulalinkProMessage_WarningTarget.WarningResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WarningResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///预警事件类型
    var warningEventType: Int32 {
      get {return _storage._warningEventType}
      set {_uniqueStorage()._warningEventType = newValue}
    }

    ///预警目标类型
    var targetType: Int32 {
      get {return _storage._targetType}
      set {_uniqueStorage()._targetType = newValue}
    }

    ///预警目标角度
    var targetAngle: Double {
      get {return _storage._targetAngle}
      set {_uniqueStorage()._targetAngle = newValue}
    }

    ///预警目标距离
    var targetDistance: Double {
      get {return _storage._targetDistance}
      set {_uniqueStorage()._targetDistance = newValue}
    }

    ///预警目标车辆类型
    var targetVehicleType: Int32 {
      get {return _storage._targetVehicleType}
      set {_uniqueStorage()._targetVehicleType = newValue}
    }

    ///预警目标车辆动力类型
    var targetVehicleFuel: Int32 {
      get {return _storage._targetVehicleFuel}
      set {_uniqueStorage()._targetVehicleFuel = newValue}
    }

    ///预警目标车辆品牌型号
    var targetVehicleBrand: Data {
      get {return _storage._targetVehicleBrand}
      set {_uniqueStorage()._targetVehicleBrand = newValue}
    }

    ///碰撞时间
    var ttc: Double {
      get {return _storage._ttc}
      set {_uniqueStorage()._ttc = newValue}
    }

    ///预警类型
    var warningType: Int32 {
      get {return _storage._warningType}
      set {_uniqueStorage()._warningType = newValue}
    }

    ///经度
    var longitude: Double {
      get {return _storage._longitude}
      set {_uniqueStorage()._longitude = newValue}
    }

    ///纬度
    var latitude: Double {
      get {return _storage._latitude}
      set {_uniqueStorage()._latitude = newValue}
    }

    ///海拔
    var altitude: Double {
      get {return _storage._altitude}
      set {_uniqueStorage()._altitude = newValue}
    }

    ///速度
    var speed: Float {
      get {return _storage._speed}
      set {_uniqueStorage()._speed = newValue}
    }

    ///速度方向
    var heading: Float {
      get {return _storage._heading}
      set {_uniqueStorage()._heading = newValue}
    }

    ///加速度
    var accel: Float {
      get {return _storage._accel}
      set {_uniqueStorage()._accel = newValue}
    }

    ///加速度方向
    var accelAngle: Float {
      get {return _storage._accelAngle}
      set {_uniqueStorage()._accelAngle = newValue}
    }

    ///定位时间
    var time: Int64 {
      get {return _storage._time}
      set {_uniqueStorage()._time = newValue}
    }

    ///车辆id
    var localID: Int32 {
      get {return _storage._localID}
      set {_uniqueStorage()._localID = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

///地图处理结果(Map Result)
struct NebulalinkProMessage_MapResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///地图处理结果
  var fromNodeID: Int64 = 0

  ///终止节点
  var toNodeID: Int64 = 0

  ///路段据终点距离
  var disToEnd: Double = 0

  ///车道ID
  var laneID: Int32 = 0

  ///路段ID
  var linkID: Int32 = 0

  ///速度上限
  var speedUpperLimit: Float = 0

  ///速度下限
  var speedFloorLimit: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///RTS处理结果(Rts Result)
struct NebulalinkProMessage_RtsResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///道路交通标志处理结果信息
  var rtsResultInformationValue: [NebulalinkProMessage_RtsResult.RtsResultInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RtsResultInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///RTS类型
    var type: Int32 = 0

    ///RTS描述
    var description_p: Data = Data()

    ///RTS结束距离
    var disToEnd: Double = 0

    ///到RTS距离
    var rdisToPath: Double = 0

    ///上游节点ID
    var upperNodeID: Int64 = 0

    ///下游节点ID
    var downNodeID: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///RTE处理结果(Rte Result)
struct NebulalinkProMessage_RteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///道路交通事件处理结果信息
  var rteResultInformationValue: [NebulalinkProMessage_RteResult.RteResultInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RteResultInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///RTE类型
    var type: Int32 = 0

    ///RTE源
    var source: Int32 = 0

    ///RTE描述
    var description_p: Data = Data()

    ///RTE结束距离
    var disToEnd: Double = 0

    ///到RTE距离
    var rdisToPath: Double = 0

    ///上游节点ID
    var upperNodeID: Int64 = 0

    ///下游节点ID
    var downNodeID: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///信号灯信息处理结果(Traffic Light Result)
struct NebulalinkProMessage_TrafficLightResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///信号灯处理结果信息
  var trafficLightResultInformationValue: [NebulalinkProMessage_TrafficLightResult.TrafficLightResultInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TrafficLightResultInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///转弯角度
    var turnerAngle: Float = 0

    ///信号灯方向
    var direction: Int32 = 0

    ///信号灯状态
    var lightState: Int32 = 0

    ///剩余时间
    var timeRemaining: Int32 = 0

    ///引导速度上限		
    var recUpperSpeed: Double = 0

    ///引导速度下限		
    var recFloorSpeed: Double = 0

    ///运动方向节点		
    var directionNodeID: Int64 = 0

    ///相位ID		
    var phaseID: Int32 = 0

    ///红绿灯减速预警
    var decelRedBreak: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///车路预警(CDAS Alert)
struct NebulalinkProMessage_CdasAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///预警目标列表
  var targetList: [NebulalinkProMessage_TargetInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///预警目标信息(Target Info)
struct NebulalinkProMessage_TargetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///目标类型
  var targetType: Int32 {
    get {return _storage._targetType}
    set {_uniqueStorage()._targetType = newValue}
  }

  ///目标设备ID
  var deviceID: Data {
    get {return _storage._deviceID}
    set {_uniqueStorage()._deviceID = newValue}
  }

  ///GNSS信息
  var gnss: NebulalinkProMessage_GnssDesc {
    get {return _storage._gnss ?? NebulalinkProMessage_GnssDesc()}
    set {_uniqueStorage()._gnss = newValue}
  }
  /// Returns true if `gnss` has been explicitly set.
  var hasGnss: Bool {return _storage._gnss != nil}
  /// Clears the value of `gnss`. Subsequent reads from it will return its default value.
  mutating func clearGnss() {_uniqueStorage()._gnss = nil}

  ///车辆基本信息
  var vehInfo: NebulalinkProMessage_VehicleInfoDesc {
    get {return _storage._vehInfo ?? NebulalinkProMessage_VehicleInfoDesc()}
    set {_uniqueStorage()._vehInfo = newValue}
  }
  /// Returns true if `vehInfo` has been explicitly set.
  var hasVehInfo: Bool {return _storage._vehInfo != nil}
  /// Clears the value of `vehInfo`. Subsequent reads from it will return its default value.
  mutating func clearVehInfo() {_uniqueStorage()._vehInfo = nil}

  ///逻辑地图分析结果
  var lmRes: NebulalinkProMessage_LogicMapResult {
    get {return _storage._lmRes ?? NebulalinkProMessage_LogicMapResult()}
    set {_uniqueStorage()._lmRes = newValue}
  }
  /// Returns true if `lmRes` has been explicitly set.
  var hasLmRes: Bool {return _storage._lmRes != nil}
  /// Clears the value of `lmRes`. Subsequent reads from it will return its default value.
  mutating func clearLmRes() {_uniqueStorage()._lmRes = nil}

  ///历史路径分析结果
  var phRes: NebulalinkProMessage_PathHistroyResult {
    get {return _storage._phRes ?? NebulalinkProMessage_PathHistroyResult()}
    set {_uniqueStorage()._phRes = newValue}
  }
  /// Returns true if `phRes` has been explicitly set.
  var hasPhRes: Bool {return _storage._phRes != nil}
  /// Clears the value of `phRes`. Subsequent reads from it will return its default value.
  mutating func clearPhRes() {_uniqueStorage()._phRes = nil}

  ///预测路径分析结果
  var ppRes: NebulalinkProMessage_PathPredictResult {
    get {return _storage._ppRes ?? NebulalinkProMessage_PathPredictResult()}
    set {_uniqueStorage()._ppRes = newValue}
  }
  /// Returns true if `ppRes` has been explicitly set.
  var hasPpRes: Bool {return _storage._ppRes != nil}
  /// Clears the value of `ppRes`. Subsequent reads from it will return its default value.
  mutating func clearPpRes() {_uniqueStorage()._ppRes = nil}

  ///位置分析结果
  var posRes: NebulalinkProMessage_PositionResult {
    get {return _storage._posRes ?? NebulalinkProMessage_PositionResult()}
    set {_uniqueStorage()._posRes = newValue}
  }
  /// Returns true if `posRes` has been explicitly set.
  var hasPosRes: Bool {return _storage._posRes != nil}
  /// Clears the value of `posRes`. Subsequent reads from it will return its default value.
  mutating func clearPosRes() {_uniqueStorage()._posRes = nil}

  ///目标方位描述
  var tdRes: NebulalinkProMessage_TargetDirectionDesc {
    get {return _storage._tdRes ?? NebulalinkProMessage_TargetDirectionDesc()}
    set {_uniqueStorage()._tdRes = newValue}
  }
  /// Returns true if `tdRes` has been explicitly set.
  var hasTdRes: Bool {return _storage._tdRes != nil}
  /// Clears the value of `tdRes`. Subsequent reads from it will return its default value.
  mutating func clearTdRes() {_uniqueStorage()._tdRes = nil}

  ///目标预警描述
  var twRes: NebulalinkProMessage_TargetWarnDesc {
    get {return _storage._twRes ?? NebulalinkProMessage_TargetWarnDesc()}
    set {_uniqueStorage()._twRes = newValue}
  }
  /// Returns true if `twRes` has been explicitly set.
  var hasTwRes: Bool {return _storage._twRes != nil}
  /// Clears the value of `twRes`. Subsequent reads from it will return its default value.
  mutating func clearTwRes() {_uniqueStorage()._twRes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///GNSS信息(Gnss Desc)
struct NebulalinkProMessage_GnssDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///经度
  var longitude: Double = 0

  ///纬度
  var latitude: Double = 0

  ///海拔
  var altitude: Double = 0

  ///时间戳
  var time: Int64 = 0

  ///速度
  var speed: Float = 0

  ///速度方向
  var heading: Float = 0

  ///加速度
  var accel: Float = 0

  ///加速度方向
  var accelAngle: Float = 0

  ///纵向加速度
  var acc4WayLon: Float = 0

  ///横向加速度
  var acc4WayLat: Float = 0

  ///垂直加速度
  var acc4WayVert: Float = 0

  ///角加速度
  var acc4WayYaw: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///车辆基本信息(Vehicle Info Desc)
struct NebulalinkProMessage_VehicleInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///车牌号
  var vehNum: Data = Data()

  ///车辆品牌
  var vehBrand: Data = Data()

  ///车辆类型
  var vehType: Int32 = 0

  ///燃油类型
  var fuelType: Int32 = 0

  ///长
  var length: Float = 0

  ///宽
  var width: Float = 0

  ///高
  var height: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///逻辑地图分析结果(Logic Map Result)
struct NebulalinkProMessage_LogicMapResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: NebulalinkProMessage_LogicMapResult.OneOf_Result? = nil

  ///同向道路结果
  var sameLink: NebulalinkProMessage_SameDirectionLink {
    get {
      if case .sameLink(let v)? = result {return v}
      return NebulalinkProMessage_SameDirectionLink()
    }
    set {result = .sameLink(newValue)}
  }

  ///反向道路结果
  var opposite: NebulalinkProMessage_OppositeDirectionLink {
    get {
      if case .opposite(let v)? = result {return v}
      return NebulalinkProMessage_OppositeDirectionLink()
    }
    set {result = .opposite(newValue)}
  }

  ///驶入交叉路口结果
  var intersection: NebulalinkProMessage_ApproachIntersection {
    get {
      if case .intersection(let v)? = result {return v}
      return NebulalinkProMessage_ApproachIntersection()
    }
    set {result = .intersection(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    ///同向道路结果
    case sameLink(NebulalinkProMessage_SameDirectionLink)
    ///反向道路结果
    case opposite(NebulalinkProMessage_OppositeDirectionLink)
    ///驶入交叉路口结果
    case intersection(NebulalinkProMessage_ApproachIntersection)

  #if !swift(>=4.1)
    static func ==(lhs: NebulalinkProMessage_LogicMapResult.OneOf_Result, rhs: NebulalinkProMessage_LogicMapResult.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sameLink, .sameLink): return {
        guard case .sameLink(let l) = lhs, case .sameLink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.opposite, .opposite): return {
        guard case .opposite(let l) = lhs, case .opposite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intersection, .intersection): return {
        guard case .intersection(let l) = lhs, case .intersection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///同向道路结果(Same Direction Link)
struct NebulalinkProMessage_SameDirectionLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///上游node id
  var fromNode: Int64 = 0

  ///下游node id
  var toNode: Int64 = 0

  ///车道信息
  var laneInfo: Bool = false

  ///车道间隔数
  var laneNum: Int32 = 0

  ///路网纵向距离
  var lonDis: Float = 0

  ///路网横向距离
  var latDis: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///反向道路结果(Opposite Direction Link)
struct NebulalinkProMessage_OppositeDirectionLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///上游node id
  var fromNode: Int64 = 0

  ///下游node id
  var toNode: Int64 = 0

  ///车道信息
  var laneInfo: Bool = false

  ///车道间隔数
  var laneNum: Int32 = 0

  ///路网纵向距离
  var lonDis: Float = 0

  ///路网横向距离
  var latDis: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///驶入交叉路口结果(Approach Intersection)
struct NebulalinkProMessage_ApproachIntersection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///上游node id
  var fromNode: Int64 = 0

  ///下游node id
  var toNode: Int64 = 0

  ///远端node id
  var remoteNode: Int64 = 0

  ///主车至路口距离
  var hvDis: Float = 0

  ///远车至路口距离
  var rvDis: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///历史路径分析结果(Path Histroy Result)
struct NebulalinkProMessage_PathHistroyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///相对位置类型
  var type: Int32 = 0

  ///历史纵向距离
  var lonDis: Float = 0

  ///历史横向距离
  var latDis: Float = 0

  ///历史路径角度差
  var headDiff: Float = 0

  ///车头时距
  var timeDis: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///预测路径分析结果(Path Predict Result)
struct NebulalinkProMessage_PathPredictResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///相对位置类型
  var type: Int32 = 0

  ///预测纵向距离
  var lonDis: Float = 0

  ///预测横向距离
  var latDis: Float = 0

  ///主车至交叉点距离
  var hvNodeDis: Float = 0

  ///远车至交叉点距离
  var rvNodeDis: Float = 0

  ///预测路径角度差
  var headDiff: Float = 0

  ///车头时距
  var timeDis: Float = 0

  ///交叉点时间差
  var nodeTimeDis: Float = 0

  ///置信度
  var confidence: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///位置分析结果(Position Result)
struct NebulalinkProMessage_PositionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///车辆角度差
  var angle: Float = 0

  ///两车直线距离
  var distance: Float = 0

  ///两车纵向距离
  var lonDis: Float = 0

  ///两车横向距离
  var latDis: Float = 0

  ///行驶方向角度差
  var dirDiff: Float = 0

  ///主车至交叉点距离
  var hvNodeDis: Float = 0

  ///远车至交叉点距离
  var rvNodeDis: Float = 0

  ///置信度
  var confidence: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///目标方位描述(Target Direction Desc)
struct NebulalinkProMessage_TargetDirectionDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///目标方位
  var direction: Int32 = 0

  ///置信度
  var confidence: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///目标预警描述(Target Warn Desc)
struct NebulalinkProMessage_TargetWarnDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///预警目标列表
  var twInfo: [NebulalinkProMessage_TargetWarnInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///目标预警信息(Target Warn Info)
struct NebulalinkProMessage_TargetWarnInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var choice: NebulalinkProMessage_TargetWarnInfo.OneOf_Choice? = nil

  ///前向碰撞预警
  var fcw: NebulalinkProMessage_FCWInfoDesc {
    get {
      if case .fcw(let v)? = choice {return v}
      return NebulalinkProMessage_FCWInfoDesc()
    }
    set {choice = .fcw(newValue)}
  }

  ///交叉口碰撞预警
  var icw: NebulalinkProMessage_ICWInfoDesc {
    get {
      if case .icw(let v)? = choice {return v}
      return NebulalinkProMessage_ICWInfoDesc()
    }
    set {choice = .icw(newValue)}
  }

  ///失控车辆预警
  var clw: NebulalinkProMessage_CLWInfoDesc {
    get {
      if case .clw(let v)? = choice {return v}
      return NebulalinkProMessage_CLWInfoDesc()
    }
    set {choice = .clw(newValue)}
  }

  ///异常车辆预警
  var avw: NebulalinkProMessage_AVWInfoDesc {
    get {
      if case .avw(let v)? = choice {return v}
      return NebulalinkProMessage_AVWInfoDesc()
    }
    set {choice = .avw(newValue)}
  }

  ///紧急刹车预警
  var ebw: NebulalinkProMessage_EBWInfoDesc {
    get {
      if case .ebw(let v)? = choice {return v}
      return NebulalinkProMessage_EBWInfoDesc()
    }
    set {choice = .ebw(newValue)}
  }

  ///逆向超车预警
  var dnpw: NebulalinkProMessage_DNPWInfoDesc {
    get {
      if case .dnpw(let v)? = choice {return v}
      return NebulalinkProMessage_DNPWInfoDesc()
    }
    set {choice = .dnpw(newValue)}
  }

  ///变道预警
  var lcw: NebulalinkProMessage_LCWInfoDesc {
    get {
      if case .lcw(let v)? = choice {return v}
      return NebulalinkProMessage_LCWInfoDesc()
    }
    set {choice = .lcw(newValue)}
  }

  ///左转辅助预警
  var lta: NebulalinkProMessage_LTAInfoDesc {
    get {
      if case .lta(let v)? = choice {return v}
      return NebulalinkProMessage_LTAInfoDesc()
    }
    set {choice = .lta(newValue)}
  }

  ///紧急车辆预警
  var evw: NebulalinkProMessage_EVWInfoDesc {
    get {
      if case .evw(let v)? = choice {return v}
      return NebulalinkProMessage_EVWInfoDesc()
    }
    set {choice = .evw(newValue)}
  }

  ///跟车预警
  var fvw: NebulalinkProMessage_FVWInfoDesc {
    get {
      if case .fvw(let v)? = choice {return v}
      return NebulalinkProMessage_FVWInfoDesc()
    }
    set {choice = .fvw(newValue)}
  }

  ///盲区预警
  var bsw: NebulalinkProMessage_BSWInfoDesc {
    get {
      if case .bsw(let v)? = choice {return v}
      return NebulalinkProMessage_BSWInfoDesc()
    }
    set {choice = .bsw(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Choice: Equatable {
    ///前向碰撞预警
    case fcw(NebulalinkProMessage_FCWInfoDesc)
    ///交叉口碰撞预警
    case icw(NebulalinkProMessage_ICWInfoDesc)
    ///失控车辆预警
    case clw(NebulalinkProMessage_CLWInfoDesc)
    ///异常车辆预警
    case avw(NebulalinkProMessage_AVWInfoDesc)
    ///紧急刹车预警
    case ebw(NebulalinkProMessage_EBWInfoDesc)
    ///逆向超车预警
    case dnpw(NebulalinkProMessage_DNPWInfoDesc)
    ///变道预警
    case lcw(NebulalinkProMessage_LCWInfoDesc)
    ///左转辅助预警
    case lta(NebulalinkProMessage_LTAInfoDesc)
    ///紧急车辆预警
    case evw(NebulalinkProMessage_EVWInfoDesc)
    ///跟车预警
    case fvw(NebulalinkProMessage_FVWInfoDesc)
    ///盲区预警
    case bsw(NebulalinkProMessage_BSWInfoDesc)

  #if !swift(>=4.1)
    static func ==(lhs: NebulalinkProMessage_TargetWarnInfo.OneOf_Choice, rhs: NebulalinkProMessage_TargetWarnInfo.OneOf_Choice) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fcw, .fcw): return {
        guard case .fcw(let l) = lhs, case .fcw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.icw, .icw): return {
        guard case .icw(let l) = lhs, case .icw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clw, .clw): return {
        guard case .clw(let l) = lhs, case .clw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avw, .avw): return {
        guard case .avw(let l) = lhs, case .avw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ebw, .ebw): return {
        guard case .ebw(let l) = lhs, case .ebw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dnpw, .dnpw): return {
        guard case .dnpw(let l) = lhs, case .dnpw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lcw, .lcw): return {
        guard case .lcw(let l) = lhs, case .lcw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lta, .lta): return {
        guard case .lta(let l) = lhs, case .lta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evw, .evw): return {
        guard case .evw(let l) = lhs, case .evw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fvw, .fvw): return {
        guard case .fvw(let l) = lhs, case .fvw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bsw, .bsw): return {
        guard case .bsw(let l) = lhs, case .bsw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///前向碰撞预警 (FCW Info Desc)
struct NebulalinkProMessage_FCWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交叉口碰撞预警(ICW Info Desc)
struct NebulalinkProMessage_ICWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///错车时间
  var dTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///失控车辆预警(CLW Info Desc)
struct NebulalinkProMessage_CLWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///异常车辆预警(AVW Info Desc)
struct NebulalinkProMessage_AVWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///紧急刹车预警(EBW Info Desc)
struct NebulalinkProMessage_EBWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///逆向超车预警(DNPW Info Desc)
struct NebulalinkProMessage_DNPWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///变道预警(LCW Info Desc)
struct NebulalinkProMessage_LCWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///左转辅助预警(LTA Info Desc)
struct NebulalinkProMessage_LTAInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///错车时间
  var dTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///紧急车辆预警(EVW Info Desc)
struct NebulalinkProMessage_EVWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///跟车预警(FVW Info Desc)
struct NebulalinkProMessage_FVWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///盲区预警(BSW Info Desc)
struct NebulalinkProMessage_BSWInfoDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///置信度
  var confidence: Int32 = 0

  ///碰撞时间
  var cTime: Float = 0

  ///车头时距
  var hTime: Float = 0

  ///场景子类型
  var subtype: Int32 = 0

  ///预警等级
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///配置信息(Configuration)
struct NebulalinkProMessage_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///配置单元信息
  var configurationInformationValue: [NebulalinkProMessage_Configuration.ConfigurationInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ConfigurationInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///配置信息名称
    var configName: Data = Data()

    ///配置信息类型
    var configType: Int32 = 0

    ///配置信息内容int
    var configValueInt: Int32 = 0

    ///配置信息内容string
    var configValueString: Data = Data()

    ///配置信息内容double
    var configValueDouble: Double = 0

    ///配置名称长度
    var keyLength: Int32 = 0

    ///配置内容长度
    var valueLength: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nebulalink_pro_message"

extension NebulalinkProMessage_RegisterFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
    2: .same(proto: "name"),
    3: .same(proto: "SetPermissionValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elementType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.setPermissionValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elementType != 0 {
      try visitor.visitSingularInt32Field(value: self.elementType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 2)
    }
    if !self.setPermissionValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.setPermissionValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RegisterFrame, rhs: NebulalinkProMessage_RegisterFrame) -> Bool {
    if lhs.elementType != rhs.elementType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.setPermissionValue != rhs.setPermissionValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RegisterFrame.SetPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RegisterFrame.protoMessageName + ".SetPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "level"),
    3: .standard(proto: "time_interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 2)
    }
    if self.timeInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.timeInterval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RegisterFrame.SetPermission, rhs: NebulalinkProMessage_RegisterFrame.SetPermission) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.level != rhs.level {return false}
    if lhs.timeInterval != rhs.timeInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RequestFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elementType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elementType != 0 {
      try visitor.visitSingularInt32Field(value: self.elementType, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RequestFrame, rhs: NebulalinkProMessage_RequestFrame) -> Bool {
    if lhs.elementType != rhs.elementType {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_ResponseFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
    2: .same(proto: "type"),
    3: .same(proto: "CommunicationRecordValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elementType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.communicationRecordValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elementType != 0 {
      try visitor.visitSingularInt32Field(value: self.elementType, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.communicationRecordValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.communicationRecordValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_ResponseFrame, rhs: NebulalinkProMessage_ResponseFrame) -> Bool {
    if lhs.elementType != rhs.elementType {return false}
    if lhs.type != rhs.type {return false}
    if lhs.communicationRecordValue != rhs.communicationRecordValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_ResponseFrame.CommunicationRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_ResponseFrame.protoMessageName + ".CommunicationRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_type"),
    2: .standard(proto: "send_count"),
    3: .standard(proto: "send_total_byte"),
    4: .standard(proto: "recv_count"),
    5: .standard(proto: "recv_total_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.msgType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sendCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sendTotalByte) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.recvCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.recvTotalCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgType != 0 {
      try visitor.visitSingularInt32Field(value: self.msgType, fieldNumber: 1)
    }
    if self.sendCount != 0 {
      try visitor.visitSingularInt32Field(value: self.sendCount, fieldNumber: 2)
    }
    if self.sendTotalByte != 0 {
      try visitor.visitSingularInt32Field(value: self.sendTotalByte, fieldNumber: 3)
    }
    if self.recvCount != 0 {
      try visitor.visitSingularInt32Field(value: self.recvCount, fieldNumber: 4)
    }
    if self.recvTotalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.recvTotalCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_ResponseFrame.CommunicationRecord, rhs: NebulalinkProMessage_ResponseFrame.CommunicationRecord) -> Bool {
    if lhs.msgType != rhs.msgType {return false}
    if lhs.sendCount != rhs.sendCount {return false}
    if lhs.sendTotalByte != rhs.sendTotalByte {return false}
    if lhs.recvCount != rhs.recvCount {return false}
    if lhs.recvTotalCount != rhs.recvTotalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_HostInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "altitude"),
    4: .standard(proto: "device_type"),
    5: .same(proto: "HostObuValue"),
    6: .same(proto: "HostRsuValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.deviceType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.hostObuValue) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.hostRsuValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 3)
    }
    if self.deviceType != 0 {
      try visitor.visitSingularInt32Field(value: self.deviceType, fieldNumber: 4)
    }
    if !self.hostObuValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hostObuValue, fieldNumber: 5)
    }
    if !self.hostRsuValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hostRsuValue, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_HostInfo, rhs: NebulalinkProMessage_HostInfo) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.hostObuValue != rhs.hostObuValue {return false}
    if lhs.hostRsuValue != rhs.hostRsuValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_HostInfo.HostObu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_HostInfo.protoMessageName + ".HostObu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "expand_information"),
    3: .standard(proto: "plate_num"),
    4: .standard(proto: "vehicle_class"),
    5: .standard(proto: "fuel_type"),
    6: .standard(proto: "brand_and_type"),
    7: .same(proto: "length"),
    8: .same(proto: "width"),
    9: .same(proto: "height"),
    10: .same(proto: "speed"),
    11: .same(proto: "heading"),
    12: .same(proto: "accel"),
    13: .standard(proto: "accel_angle"),
    14: .same(proto: "time"),
    15: .standard(proto: "positioning_state"),
    16: .standard(proto: "satellite_number"),
    17: .same(proto: "precision"),
    18: .standard(proto: "transmission_state_source"),
    19: .standard(proto: "transmission_state"),
    20: .standard(proto: "speed_can_valid"),
    21: .standard(proto: "speed_can"),
    22: .standard(proto: "heading_can_speed"),
    23: .standard(proto: "heading_can"),
    24: .standard(proto: "steering_wheel_angle_valid"),
    25: .standard(proto: "steering_wheel_angle"),
    26: .standard(proto: "acc4way_valid"),
    27: .standard(proto: "acc4way_lon"),
    28: .standard(proto: "acc4way_lat"),
    29: .standard(proto: "acc4way_vert"),
    30: .standard(proto: "acc4way_yaw"),
    31: .standard(proto: "brake_state_valid"),
    32: .standard(proto: "brake_pedal_state"),
    33: .standard(proto: "brake_applied_state"),
    34: .standard(proto: "traction_control_state"),
    35: .standard(proto: "abs_state"),
    36: .standard(proto: "stability_control_state"),
    37: .standard(proto: "brake_boost_applied"),
    38: .standard(proto: "auxiliary_brake_state"),
    39: .standard(proto: "vehicle_event_flag_source"),
    40: .standard(proto: "vehicle_event_flag"),
    41: .standard(proto: "vehicle_lights_state_source"),
    42: .standard(proto: "vehicle_lights_state"),
    43: .standard(proto: "brake_pedal_depth_source"),
    44: .standard(proto: "brake_pedal_depth"),
    45: .same(proto: "MapInformationValue"),
  ]

  fileprivate class _StorageClass {
    var _deviceID: Data = Data()
    var _expandInformation: Data = Data()
    var _plateNum: Data = Data()
    var _vehicleClass: Int32 = 0
    var _fuelType: Int32 = 0
    var _brandAndType: Data = Data()
    var _length: Float = 0
    var _width: Float = 0
    var _height: Float = 0
    var _speed: Float = 0
    var _heading: Float = 0
    var _accel: Float = 0
    var _accelAngle: Float = 0
    var _time: Int64 = 0
    var _positioningState: Int32 = 0
    var _satelliteNumber: Int32 = 0
    var _precision: Float = 0
    var _transmissionStateSource: Int32 = 0
    var _transmissionState: Int32 = 0
    var _speedCanValid: Int32 = 0
    var _speedCan: Float = 0
    var _headingCanSpeed: Int32 = 0
    var _headingCan: Float = 0
    var _steeringWheelAngleValid: Int32 = 0
    var _steeringWheelAngle: Float = 0
    var _acc4WayValid: Int32 = 0
    var _acc4WayLon: Float = 0
    var _acc4WayLat: Float = 0
    var _acc4WayVert: Float = 0
    var _acc4WayYaw: Float = 0
    var _brakeStateValid: Int32 = 0
    var _brakePedalState: Int32 = 0
    var _brakeAppliedState: Int32 = 0
    var _tractionControlState: Int32 = 0
    var _absState: Int32 = 0
    var _stabilityControlState: Int32 = 0
    var _brakeBoostApplied: Int32 = 0
    var _auxiliaryBrakeState: Int32 = 0
    var _vehicleEventFlagSource: Int32 = 0
    var _vehicleEventFlag: Int32 = 0
    var _vehicleLightsStateSource: Int32 = 0
    var _vehicleLightsState: Int32 = 0
    var _brakePedalDepthSource: Int32 = 0
    var _brakePedalDepth: Float = 0
    var _mapInformationValue: [NebulalinkProMessage_HostInfo.HostObu.MapInformation] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceID = source._deviceID
      _expandInformation = source._expandInformation
      _plateNum = source._plateNum
      _vehicleClass = source._vehicleClass
      _fuelType = source._fuelType
      _brandAndType = source._brandAndType
      _length = source._length
      _width = source._width
      _height = source._height
      _speed = source._speed
      _heading = source._heading
      _accel = source._accel
      _accelAngle = source._accelAngle
      _time = source._time
      _positioningState = source._positioningState
      _satelliteNumber = source._satelliteNumber
      _precision = source._precision
      _transmissionStateSource = source._transmissionStateSource
      _transmissionState = source._transmissionState
      _speedCanValid = source._speedCanValid
      _speedCan = source._speedCan
      _headingCanSpeed = source._headingCanSpeed
      _headingCan = source._headingCan
      _steeringWheelAngleValid = source._steeringWheelAngleValid
      _steeringWheelAngle = source._steeringWheelAngle
      _acc4WayValid = source._acc4WayValid
      _acc4WayLon = source._acc4WayLon
      _acc4WayLat = source._acc4WayLat
      _acc4WayVert = source._acc4WayVert
      _acc4WayYaw = source._acc4WayYaw
      _brakeStateValid = source._brakeStateValid
      _brakePedalState = source._brakePedalState
      _brakeAppliedState = source._brakeAppliedState
      _tractionControlState = source._tractionControlState
      _absState = source._absState
      _stabilityControlState = source._stabilityControlState
      _brakeBoostApplied = source._brakeBoostApplied
      _auxiliaryBrakeState = source._auxiliaryBrakeState
      _vehicleEventFlagSource = source._vehicleEventFlagSource
      _vehicleEventFlag = source._vehicleEventFlag
      _vehicleLightsStateSource = source._vehicleLightsStateSource
      _vehicleLightsState = source._vehicleLightsState
      _brakePedalDepthSource = source._brakePedalDepthSource
      _brakePedalDepth = source._brakePedalDepth
      _mapInformationValue = source._mapInformationValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._deviceID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._expandInformation) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._plateNum) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleClass) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._fuelType) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._brandAndType) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._length) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._width) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._height) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._speed) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._heading) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._accel) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._accelAngle) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._positioningState) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._satelliteNumber) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._precision) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._transmissionStateSource) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._transmissionState) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._speedCanValid) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._speedCan) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._headingCanSpeed) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._headingCan) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._steeringWheelAngleValid) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._steeringWheelAngle) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._acc4WayValid) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayLon) }()
        case 28: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayLat) }()
        case 29: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayVert) }()
        case 30: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayYaw) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeStateValid) }()
        case 32: try { try decoder.decodeSingularInt32Field(value: &_storage._brakePedalState) }()
        case 33: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeAppliedState) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._tractionControlState) }()
        case 35: try { try decoder.decodeSingularInt32Field(value: &_storage._absState) }()
        case 36: try { try decoder.decodeSingularInt32Field(value: &_storage._stabilityControlState) }()
        case 37: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeBoostApplied) }()
        case 38: try { try decoder.decodeSingularInt32Field(value: &_storage._auxiliaryBrakeState) }()
        case 39: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleEventFlagSource) }()
        case 40: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleEventFlag) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleLightsStateSource) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleLightsState) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._brakePedalDepthSource) }()
        case 44: try { try decoder.decodeSingularFloatField(value: &_storage._brakePedalDepth) }()
        case 45: try { try decoder.decodeRepeatedMessageField(value: &_storage._mapInformationValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceID, fieldNumber: 1)
      }
      if !_storage._expandInformation.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._expandInformation, fieldNumber: 2)
      }
      if !_storage._plateNum.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._plateNum, fieldNumber: 3)
      }
      if _storage._vehicleClass != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleClass, fieldNumber: 4)
      }
      if _storage._fuelType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fuelType, fieldNumber: 5)
      }
      if !_storage._brandAndType.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._brandAndType, fieldNumber: 6)
      }
      if _storage._length != 0 {
        try visitor.visitSingularFloatField(value: _storage._length, fieldNumber: 7)
      }
      if _storage._width != 0 {
        try visitor.visitSingularFloatField(value: _storage._width, fieldNumber: 8)
      }
      if _storage._height != 0 {
        try visitor.visitSingularFloatField(value: _storage._height, fieldNumber: 9)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularFloatField(value: _storage._speed, fieldNumber: 10)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularFloatField(value: _storage._heading, fieldNumber: 11)
      }
      if _storage._accel != 0 {
        try visitor.visitSingularFloatField(value: _storage._accel, fieldNumber: 12)
      }
      if _storage._accelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._accelAngle, fieldNumber: 13)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 14)
      }
      if _storage._positioningState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._positioningState, fieldNumber: 15)
      }
      if _storage._satelliteNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._satelliteNumber, fieldNumber: 16)
      }
      if _storage._precision != 0 {
        try visitor.visitSingularFloatField(value: _storage._precision, fieldNumber: 17)
      }
      if _storage._transmissionStateSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transmissionStateSource, fieldNumber: 18)
      }
      if _storage._transmissionState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transmissionState, fieldNumber: 19)
      }
      if _storage._speedCanValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._speedCanValid, fieldNumber: 20)
      }
      if _storage._speedCan != 0 {
        try visitor.visitSingularFloatField(value: _storage._speedCan, fieldNumber: 21)
      }
      if _storage._headingCanSpeed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._headingCanSpeed, fieldNumber: 22)
      }
      if _storage._headingCan != 0 {
        try visitor.visitSingularFloatField(value: _storage._headingCan, fieldNumber: 23)
      }
      if _storage._steeringWheelAngleValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._steeringWheelAngleValid, fieldNumber: 24)
      }
      if _storage._steeringWheelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._steeringWheelAngle, fieldNumber: 25)
      }
      if _storage._acc4WayValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._acc4WayValid, fieldNumber: 26)
      }
      if _storage._acc4WayLon != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayLon, fieldNumber: 27)
      }
      if _storage._acc4WayLat != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayLat, fieldNumber: 28)
      }
      if _storage._acc4WayVert != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayVert, fieldNumber: 29)
      }
      if _storage._acc4WayYaw != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayYaw, fieldNumber: 30)
      }
      if _storage._brakeStateValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeStateValid, fieldNumber: 31)
      }
      if _storage._brakePedalState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakePedalState, fieldNumber: 32)
      }
      if _storage._brakeAppliedState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeAppliedState, fieldNumber: 33)
      }
      if _storage._tractionControlState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tractionControlState, fieldNumber: 34)
      }
      if _storage._absState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._absState, fieldNumber: 35)
      }
      if _storage._stabilityControlState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._stabilityControlState, fieldNumber: 36)
      }
      if _storage._brakeBoostApplied != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeBoostApplied, fieldNumber: 37)
      }
      if _storage._auxiliaryBrakeState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._auxiliaryBrakeState, fieldNumber: 38)
      }
      if _storage._vehicleEventFlagSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleEventFlagSource, fieldNumber: 39)
      }
      if _storage._vehicleEventFlag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleEventFlag, fieldNumber: 40)
      }
      if _storage._vehicleLightsStateSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleLightsStateSource, fieldNumber: 41)
      }
      if _storage._vehicleLightsState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleLightsState, fieldNumber: 42)
      }
      if _storage._brakePedalDepthSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakePedalDepthSource, fieldNumber: 43)
      }
      if _storage._brakePedalDepth != 0 {
        try visitor.visitSingularFloatField(value: _storage._brakePedalDepth, fieldNumber: 44)
      }
      if !_storage._mapInformationValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mapInformationValue, fieldNumber: 45)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_HostInfo.HostObu, rhs: NebulalinkProMessage_HostInfo.HostObu) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._expandInformation != rhs_storage._expandInformation {return false}
        if _storage._plateNum != rhs_storage._plateNum {return false}
        if _storage._vehicleClass != rhs_storage._vehicleClass {return false}
        if _storage._fuelType != rhs_storage._fuelType {return false}
        if _storage._brandAndType != rhs_storage._brandAndType {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._accel != rhs_storage._accel {return false}
        if _storage._accelAngle != rhs_storage._accelAngle {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._positioningState != rhs_storage._positioningState {return false}
        if _storage._satelliteNumber != rhs_storage._satelliteNumber {return false}
        if _storage._precision != rhs_storage._precision {return false}
        if _storage._transmissionStateSource != rhs_storage._transmissionStateSource {return false}
        if _storage._transmissionState != rhs_storage._transmissionState {return false}
        if _storage._speedCanValid != rhs_storage._speedCanValid {return false}
        if _storage._speedCan != rhs_storage._speedCan {return false}
        if _storage._headingCanSpeed != rhs_storage._headingCanSpeed {return false}
        if _storage._headingCan != rhs_storage._headingCan {return false}
        if _storage._steeringWheelAngleValid != rhs_storage._steeringWheelAngleValid {return false}
        if _storage._steeringWheelAngle != rhs_storage._steeringWheelAngle {return false}
        if _storage._acc4WayValid != rhs_storage._acc4WayValid {return false}
        if _storage._acc4WayLon != rhs_storage._acc4WayLon {return false}
        if _storage._acc4WayLat != rhs_storage._acc4WayLat {return false}
        if _storage._acc4WayVert != rhs_storage._acc4WayVert {return false}
        if _storage._acc4WayYaw != rhs_storage._acc4WayYaw {return false}
        if _storage._brakeStateValid != rhs_storage._brakeStateValid {return false}
        if _storage._brakePedalState != rhs_storage._brakePedalState {return false}
        if _storage._brakeAppliedState != rhs_storage._brakeAppliedState {return false}
        if _storage._tractionControlState != rhs_storage._tractionControlState {return false}
        if _storage._absState != rhs_storage._absState {return false}
        if _storage._stabilityControlState != rhs_storage._stabilityControlState {return false}
        if _storage._brakeBoostApplied != rhs_storage._brakeBoostApplied {return false}
        if _storage._auxiliaryBrakeState != rhs_storage._auxiliaryBrakeState {return false}
        if _storage._vehicleEventFlagSource != rhs_storage._vehicleEventFlagSource {return false}
        if _storage._vehicleEventFlag != rhs_storage._vehicleEventFlag {return false}
        if _storage._vehicleLightsStateSource != rhs_storage._vehicleLightsStateSource {return false}
        if _storage._vehicleLightsState != rhs_storage._vehicleLightsState {return false}
        if _storage._brakePedalDepthSource != rhs_storage._brakePedalDepthSource {return false}
        if _storage._brakePedalDepth != rhs_storage._brakePedalDepth {return false}
        if _storage._mapInformationValue != rhs_storage._mapInformationValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_HostInfo.HostObu.MapInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_HostInfo.HostObu.protoMessageName + ".MapInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_longitude"),
    2: .standard(proto: "point_latitude"),
    3: .standard(proto: "point_altitude"),
    4: .standard(proto: "point_speed"),
    5: .standard(proto: "point_heading"),
    6: .standard(proto: "point_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.pointLongitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pointLatitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pointAltitude) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pointSpeed) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pointHeading) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pointTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pointLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLongitude, fieldNumber: 1)
    }
    if self.pointLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLatitude, fieldNumber: 2)
    }
    if self.pointAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointAltitude, fieldNumber: 3)
    }
    if self.pointSpeed != 0 {
      try visitor.visitSingularFloatField(value: self.pointSpeed, fieldNumber: 4)
    }
    if self.pointHeading != 0 {
      try visitor.visitSingularFloatField(value: self.pointHeading, fieldNumber: 5)
    }
    if self.pointTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pointTime, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_HostInfo.HostObu.MapInformation, rhs: NebulalinkProMessage_HostInfo.HostObu.MapInformation) -> Bool {
    if lhs.pointLongitude != rhs.pointLongitude {return false}
    if lhs.pointLatitude != rhs.pointLatitude {return false}
    if lhs.pointAltitude != rhs.pointAltitude {return false}
    if lhs.pointSpeed != rhs.pointSpeed {return false}
    if lhs.pointHeading != rhs.pointHeading {return false}
    if lhs.pointTime != rhs.pointTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_HostInfo.HostRsu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_HostInfo.protoMessageName + ".HostRsu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_HostInfo.HostRsu, rhs: NebulalinkProMessage_HostInfo.HostRsu) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OtherObu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OtherObu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OtherObuInfoValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.otherObuInfoValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otherObuInfoValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.otherObuInfoValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OtherObu, rhs: NebulalinkProMessage_OtherObu) -> Bool {
    if lhs.otherObuInfoValue != rhs.otherObuInfoValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OtherObu.OtherObuInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_OtherObu.protoMessageName + ".OtherObuInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_id"),
    2: .standard(proto: "device_id"),
    3: .standard(proto: "plate_num"),
    4: .standard(proto: "vehicle_class"),
    5: .standard(proto: "fuel_type"),
    6: .standard(proto: "brand_and_type"),
    7: .same(proto: "length"),
    8: .same(proto: "width"),
    9: .same(proto: "height"),
    10: .same(proto: "longitude"),
    11: .same(proto: "latitude"),
    12: .same(proto: "altitude"),
    13: .same(proto: "speed"),
    14: .same(proto: "heading"),
    15: .same(proto: "accel"),
    16: .standard(proto: "accel_angle"),
    17: .same(proto: "time"),
    18: .standard(proto: "transmission_state_source"),
    19: .standard(proto: "transmission_state"),
    20: .standard(proto: "speed_can_valid"),
    21: .standard(proto: "speed_can"),
    22: .standard(proto: "heading_can_speed"),
    23: .standard(proto: "heading_can"),
    24: .standard(proto: "steering_wheel_angle_valid"),
    25: .standard(proto: "steering_wheel_angle"),
    26: .standard(proto: "acc4way_valid"),
    27: .standard(proto: "acc4way_lon"),
    28: .standard(proto: "acc4way_lat"),
    29: .standard(proto: "acc4way_vert"),
    30: .standard(proto: "acc4way_yaw"),
    31: .standard(proto: "brake_state_valid"),
    32: .standard(proto: "brake_pedal_state"),
    33: .standard(proto: "brake_applied_state"),
    34: .standard(proto: "traction_control_state"),
    35: .standard(proto: "abs_state"),
    36: .standard(proto: "stability_control_state"),
    37: .standard(proto: "brake_boost_applied"),
    38: .standard(proto: "auxiliary_brake_state"),
    39: .standard(proto: "vehicle_event_flag_source"),
    40: .standard(proto: "vehicle_event_flag"),
    41: .standard(proto: "vehicle_lights_state"),
    42: .standard(proto: "brake_pedal_depth_source"),
    43: .standard(proto: "brake_pedal_depth"),
    44: .same(proto: "MapInformationValue"),
  ]

  fileprivate class _StorageClass {
    var _localID: Int32 = 0
    var _deviceID: Data = Data()
    var _plateNum: Data = Data()
    var _vehicleClass: Int32 = 0
    var _fuelType: Int32 = 0
    var _brandAndType: Data = Data()
    var _length: Float = 0
    var _width: Float = 0
    var _height: Float = 0
    var _longitude: Double = 0
    var _latitude: Double = 0
    var _altitude: Double = 0
    var _speed: Float = 0
    var _heading: Float = 0
    var _accel: Float = 0
    var _accelAngle: Float = 0
    var _time: Int64 = 0
    var _transmissionStateSource: Int32 = 0
    var _transmissionState: Int32 = 0
    var _speedCanValid: Int32 = 0
    var _speedCan: Float = 0
    var _headingCanSpeed: Int32 = 0
    var _headingCan: Float = 0
    var _steeringWheelAngleValid: Int32 = 0
    var _steeringWheelAngle: Float = 0
    var _acc4WayValid: Int32 = 0
    var _acc4WayLon: Float = 0
    var _acc4WayLat: Float = 0
    var _acc4WayVert: Float = 0
    var _acc4WayYaw: Float = 0
    var _brakeStateValid: Int32 = 0
    var _brakePedalState: Int32 = 0
    var _brakeAppliedState: Int32 = 0
    var _tractionControlState: Int32 = 0
    var _absState: Int32 = 0
    var _stabilityControlState: Int32 = 0
    var _brakeBoostApplied: Int32 = 0
    var _auxiliaryBrakeState: Int32 = 0
    var _vehicleEventFlagSource: Int32 = 0
    var _vehicleEventFlag: Int32 = 0
    var _vehicleLightsState: Int32 = 0
    var _brakePedalDepthSource: Int32 = 0
    var _brakePedalDepth: Float = 0
    var _mapInformationValue: [NebulalinkProMessage_OtherObu.OtherObuInfo.MapInformation] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localID = source._localID
      _deviceID = source._deviceID
      _plateNum = source._plateNum
      _vehicleClass = source._vehicleClass
      _fuelType = source._fuelType
      _brandAndType = source._brandAndType
      _length = source._length
      _width = source._width
      _height = source._height
      _longitude = source._longitude
      _latitude = source._latitude
      _altitude = source._altitude
      _speed = source._speed
      _heading = source._heading
      _accel = source._accel
      _accelAngle = source._accelAngle
      _time = source._time
      _transmissionStateSource = source._transmissionStateSource
      _transmissionState = source._transmissionState
      _speedCanValid = source._speedCanValid
      _speedCan = source._speedCan
      _headingCanSpeed = source._headingCanSpeed
      _headingCan = source._headingCan
      _steeringWheelAngleValid = source._steeringWheelAngleValid
      _steeringWheelAngle = source._steeringWheelAngle
      _acc4WayValid = source._acc4WayValid
      _acc4WayLon = source._acc4WayLon
      _acc4WayLat = source._acc4WayLat
      _acc4WayVert = source._acc4WayVert
      _acc4WayYaw = source._acc4WayYaw
      _brakeStateValid = source._brakeStateValid
      _brakePedalState = source._brakePedalState
      _brakeAppliedState = source._brakeAppliedState
      _tractionControlState = source._tractionControlState
      _absState = source._absState
      _stabilityControlState = source._stabilityControlState
      _brakeBoostApplied = source._brakeBoostApplied
      _auxiliaryBrakeState = source._auxiliaryBrakeState
      _vehicleEventFlagSource = source._vehicleEventFlagSource
      _vehicleEventFlag = source._vehicleEventFlag
      _vehicleLightsState = source._vehicleLightsState
      _brakePedalDepthSource = source._brakePedalDepthSource
      _brakePedalDepth = source._brakePedalDepth
      _mapInformationValue = source._mapInformationValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._localID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._deviceID) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._plateNum) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleClass) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._fuelType) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._brandAndType) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._length) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._width) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._height) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._longitude) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._latitude) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._altitude) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._speed) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._heading) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._accel) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._accelAngle) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._transmissionStateSource) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._transmissionState) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._speedCanValid) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._speedCan) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._headingCanSpeed) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._headingCan) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._steeringWheelAngleValid) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._steeringWheelAngle) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._acc4WayValid) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayLon) }()
        case 28: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayLat) }()
        case 29: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayVert) }()
        case 30: try { try decoder.decodeSingularFloatField(value: &_storage._acc4WayYaw) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeStateValid) }()
        case 32: try { try decoder.decodeSingularInt32Field(value: &_storage._brakePedalState) }()
        case 33: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeAppliedState) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._tractionControlState) }()
        case 35: try { try decoder.decodeSingularInt32Field(value: &_storage._absState) }()
        case 36: try { try decoder.decodeSingularInt32Field(value: &_storage._stabilityControlState) }()
        case 37: try { try decoder.decodeSingularInt32Field(value: &_storage._brakeBoostApplied) }()
        case 38: try { try decoder.decodeSingularInt32Field(value: &_storage._auxiliaryBrakeState) }()
        case 39: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleEventFlagSource) }()
        case 40: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleEventFlag) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleLightsState) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._brakePedalDepthSource) }()
        case 43: try { try decoder.decodeSingularFloatField(value: &_storage._brakePedalDepth) }()
        case 44: try { try decoder.decodeRepeatedMessageField(value: &_storage._mapInformationValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._localID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._localID, fieldNumber: 1)
      }
      if !_storage._deviceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceID, fieldNumber: 2)
      }
      if !_storage._plateNum.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._plateNum, fieldNumber: 3)
      }
      if _storage._vehicleClass != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleClass, fieldNumber: 4)
      }
      if _storage._fuelType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fuelType, fieldNumber: 5)
      }
      if !_storage._brandAndType.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._brandAndType, fieldNumber: 6)
      }
      if _storage._length != 0 {
        try visitor.visitSingularFloatField(value: _storage._length, fieldNumber: 7)
      }
      if _storage._width != 0 {
        try visitor.visitSingularFloatField(value: _storage._width, fieldNumber: 8)
      }
      if _storage._height != 0 {
        try visitor.visitSingularFloatField(value: _storage._height, fieldNumber: 9)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._longitude, fieldNumber: 10)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latitude, fieldNumber: 11)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._altitude, fieldNumber: 12)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularFloatField(value: _storage._speed, fieldNumber: 13)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularFloatField(value: _storage._heading, fieldNumber: 14)
      }
      if _storage._accel != 0 {
        try visitor.visitSingularFloatField(value: _storage._accel, fieldNumber: 15)
      }
      if _storage._accelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._accelAngle, fieldNumber: 16)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 17)
      }
      if _storage._transmissionStateSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transmissionStateSource, fieldNumber: 18)
      }
      if _storage._transmissionState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transmissionState, fieldNumber: 19)
      }
      if _storage._speedCanValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._speedCanValid, fieldNumber: 20)
      }
      if _storage._speedCan != 0 {
        try visitor.visitSingularFloatField(value: _storage._speedCan, fieldNumber: 21)
      }
      if _storage._headingCanSpeed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._headingCanSpeed, fieldNumber: 22)
      }
      if _storage._headingCan != 0 {
        try visitor.visitSingularFloatField(value: _storage._headingCan, fieldNumber: 23)
      }
      if _storage._steeringWheelAngleValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._steeringWheelAngleValid, fieldNumber: 24)
      }
      if _storage._steeringWheelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._steeringWheelAngle, fieldNumber: 25)
      }
      if _storage._acc4WayValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._acc4WayValid, fieldNumber: 26)
      }
      if _storage._acc4WayLon != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayLon, fieldNumber: 27)
      }
      if _storage._acc4WayLat != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayLat, fieldNumber: 28)
      }
      if _storage._acc4WayVert != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayVert, fieldNumber: 29)
      }
      if _storage._acc4WayYaw != 0 {
        try visitor.visitSingularFloatField(value: _storage._acc4WayYaw, fieldNumber: 30)
      }
      if _storage._brakeStateValid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeStateValid, fieldNumber: 31)
      }
      if _storage._brakePedalState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakePedalState, fieldNumber: 32)
      }
      if _storage._brakeAppliedState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeAppliedState, fieldNumber: 33)
      }
      if _storage._tractionControlState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tractionControlState, fieldNumber: 34)
      }
      if _storage._absState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._absState, fieldNumber: 35)
      }
      if _storage._stabilityControlState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._stabilityControlState, fieldNumber: 36)
      }
      if _storage._brakeBoostApplied != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakeBoostApplied, fieldNumber: 37)
      }
      if _storage._auxiliaryBrakeState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._auxiliaryBrakeState, fieldNumber: 38)
      }
      if _storage._vehicleEventFlagSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleEventFlagSource, fieldNumber: 39)
      }
      if _storage._vehicleEventFlag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleEventFlag, fieldNumber: 40)
      }
      if _storage._vehicleLightsState != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleLightsState, fieldNumber: 41)
      }
      if _storage._brakePedalDepthSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brakePedalDepthSource, fieldNumber: 42)
      }
      if _storage._brakePedalDepth != 0 {
        try visitor.visitSingularFloatField(value: _storage._brakePedalDepth, fieldNumber: 43)
      }
      if !_storage._mapInformationValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mapInformationValue, fieldNumber: 44)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OtherObu.OtherObuInfo, rhs: NebulalinkProMessage_OtherObu.OtherObuInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localID != rhs_storage._localID {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._plateNum != rhs_storage._plateNum {return false}
        if _storage._vehicleClass != rhs_storage._vehicleClass {return false}
        if _storage._fuelType != rhs_storage._fuelType {return false}
        if _storage._brandAndType != rhs_storage._brandAndType {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._accel != rhs_storage._accel {return false}
        if _storage._accelAngle != rhs_storage._accelAngle {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._transmissionStateSource != rhs_storage._transmissionStateSource {return false}
        if _storage._transmissionState != rhs_storage._transmissionState {return false}
        if _storage._speedCanValid != rhs_storage._speedCanValid {return false}
        if _storage._speedCan != rhs_storage._speedCan {return false}
        if _storage._headingCanSpeed != rhs_storage._headingCanSpeed {return false}
        if _storage._headingCan != rhs_storage._headingCan {return false}
        if _storage._steeringWheelAngleValid != rhs_storage._steeringWheelAngleValid {return false}
        if _storage._steeringWheelAngle != rhs_storage._steeringWheelAngle {return false}
        if _storage._acc4WayValid != rhs_storage._acc4WayValid {return false}
        if _storage._acc4WayLon != rhs_storage._acc4WayLon {return false}
        if _storage._acc4WayLat != rhs_storage._acc4WayLat {return false}
        if _storage._acc4WayVert != rhs_storage._acc4WayVert {return false}
        if _storage._acc4WayYaw != rhs_storage._acc4WayYaw {return false}
        if _storage._brakeStateValid != rhs_storage._brakeStateValid {return false}
        if _storage._brakePedalState != rhs_storage._brakePedalState {return false}
        if _storage._brakeAppliedState != rhs_storage._brakeAppliedState {return false}
        if _storage._tractionControlState != rhs_storage._tractionControlState {return false}
        if _storage._absState != rhs_storage._absState {return false}
        if _storage._stabilityControlState != rhs_storage._stabilityControlState {return false}
        if _storage._brakeBoostApplied != rhs_storage._brakeBoostApplied {return false}
        if _storage._auxiliaryBrakeState != rhs_storage._auxiliaryBrakeState {return false}
        if _storage._vehicleEventFlagSource != rhs_storage._vehicleEventFlagSource {return false}
        if _storage._vehicleEventFlag != rhs_storage._vehicleEventFlag {return false}
        if _storage._vehicleLightsState != rhs_storage._vehicleLightsState {return false}
        if _storage._brakePedalDepthSource != rhs_storage._brakePedalDepthSource {return false}
        if _storage._brakePedalDepth != rhs_storage._brakePedalDepth {return false}
        if _storage._mapInformationValue != rhs_storage._mapInformationValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OtherObu.OtherObuInfo.MapInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_OtherObu.OtherObuInfo.protoMessageName + ".MapInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_longitude"),
    2: .standard(proto: "point_latitude"),
    3: .standard(proto: "point_altitude"),
    4: .standard(proto: "point_speed"),
    5: .standard(proto: "point_heading"),
    6: .standard(proto: "point_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.pointLongitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pointLatitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pointAltitude) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pointSpeed) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pointHeading) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pointTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pointLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLongitude, fieldNumber: 1)
    }
    if self.pointLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLatitude, fieldNumber: 2)
    }
    if self.pointAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointAltitude, fieldNumber: 3)
    }
    if self.pointSpeed != 0 {
      try visitor.visitSingularFloatField(value: self.pointSpeed, fieldNumber: 4)
    }
    if self.pointHeading != 0 {
      try visitor.visitSingularFloatField(value: self.pointHeading, fieldNumber: 5)
    }
    if self.pointTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pointTime, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OtherObu.OtherObuInfo.MapInformation, rhs: NebulalinkProMessage_OtherObu.OtherObuInfo.MapInformation) -> Bool {
    if lhs.pointLongitude != rhs.pointLongitude {return false}
    if lhs.pointLatitude != rhs.pointLatitude {return false}
    if lhs.pointAltitude != rhs.pointAltitude {return false}
    if lhs.pointSpeed != rhs.pointSpeed {return false}
    if lhs.pointHeading != rhs.pointHeading {return false}
    if lhs.pointTime != rhs.pointTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OtherRsu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OtherRsu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OtherRsuInfoValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.otherRsuInfoValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otherRsuInfoValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.otherRsuInfoValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OtherRsu, rhs: NebulalinkProMessage_OtherRsu) -> Bool {
    if lhs.otherRsuInfoValue != rhs.otherRsuInfoValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OtherRsu.OtherRsuInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_OtherRsu.protoMessageName + ".OtherRsuInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_id"),
    2: .same(proto: "version"),
    3: .standard(proto: "device_id"),
    4: .same(proto: "longitude"),
    5: .same(proto: "latitude"),
    6: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.localID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.deviceID) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.localID != 0 {
      try visitor.visitSingularInt32Field(value: self.localID, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 3)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 4)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 5)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OtherRsu.OtherRsuInfo, rhs: NebulalinkProMessage_OtherRsu.OtherRsuInfo) -> Bool {
    if lhs.localID != rhs.localID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PTV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PTV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PtvInfomationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ptvInfomationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ptvInfomationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ptvInfomationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PTV, rhs: NebulalinkProMessage_PTV) -> Bool {
    if lhs.ptvInfomationValue != rhs.ptvInfomationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PTV.PtvInfomation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_PTV.protoMessageName + ".PtvInfomation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "source_type"),
    3: .standard(proto: "source_id"),
    4: .standard(proto: "device_id"),
    5: .standard(proto: "plate_num"),
    6: .standard(proto: "vehicle_class"),
    7: .standard(proto: "fuel_type"),
    8: .standard(proto: "brand_and_type"),
    9: .same(proto: "length"),
    10: .same(proto: "width"),
    11: .same(proto: "height"),
    12: .same(proto: "longitude"),
    13: .same(proto: "latitude"),
    14: .same(proto: "altitude"),
    15: .same(proto: "speed"),
    16: .same(proto: "heading"),
    17: .same(proto: "accel"),
    18: .standard(proto: "accel_angle"),
    19: .same(proto: "time"),
    20: .same(proto: "precision"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _sourceType: Int32 = 0
    var _sourceID: Data = Data()
    var _deviceID: Data = Data()
    var _plateNum: Data = Data()
    var _vehicleClass: Int32 = 0
    var _fuelType: Int32 = 0
    var _brandAndType: Data = Data()
    var _length: Float = 0
    var _width: Float = 0
    var _height: Float = 0
    var _longitude: Double = 0
    var _latitude: Double = 0
    var _altitude: Double = 0
    var _speed: Float = 0
    var _heading: Float = 0
    var _accel: Float = 0
    var _accelAngle: Float = 0
    var _time: Int64 = 0
    var _precision: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _sourceType = source._sourceType
      _sourceID = source._sourceID
      _deviceID = source._deviceID
      _plateNum = source._plateNum
      _vehicleClass = source._vehicleClass
      _fuelType = source._fuelType
      _brandAndType = source._brandAndType
      _length = source._length
      _width = source._width
      _height = source._height
      _longitude = source._longitude
      _latitude = source._latitude
      _altitude = source._altitude
      _speed = source._speed
      _heading = source._heading
      _accel = source._accel
      _accelAngle = source._accelAngle
      _time = source._time
      _precision = source._precision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._sourceType) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._sourceID) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._deviceID) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._plateNum) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._vehicleClass) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._fuelType) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._brandAndType) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._length) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._width) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._height) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._longitude) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._latitude) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._altitude) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._speed) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._heading) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._accel) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._accelAngle) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._precision) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._sourceType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sourceType, fieldNumber: 2)
      }
      if !_storage._sourceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._sourceID, fieldNumber: 3)
      }
      if !_storage._deviceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceID, fieldNumber: 4)
      }
      if !_storage._plateNum.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._plateNum, fieldNumber: 5)
      }
      if _storage._vehicleClass != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vehicleClass, fieldNumber: 6)
      }
      if _storage._fuelType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fuelType, fieldNumber: 7)
      }
      if !_storage._brandAndType.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._brandAndType, fieldNumber: 8)
      }
      if _storage._length != 0 {
        try visitor.visitSingularFloatField(value: _storage._length, fieldNumber: 9)
      }
      if _storage._width != 0 {
        try visitor.visitSingularFloatField(value: _storage._width, fieldNumber: 10)
      }
      if _storage._height != 0 {
        try visitor.visitSingularFloatField(value: _storage._height, fieldNumber: 11)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._longitude, fieldNumber: 12)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latitude, fieldNumber: 13)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._altitude, fieldNumber: 14)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularFloatField(value: _storage._speed, fieldNumber: 15)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularFloatField(value: _storage._heading, fieldNumber: 16)
      }
      if _storage._accel != 0 {
        try visitor.visitSingularFloatField(value: _storage._accel, fieldNumber: 17)
      }
      if _storage._accelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._accelAngle, fieldNumber: 18)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 19)
      }
      if _storage._precision != 0 {
        try visitor.visitSingularFloatField(value: _storage._precision, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PTV.PtvInfomation, rhs: NebulalinkProMessage_PTV.PtvInfomation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._sourceType != rhs_storage._sourceType {return false}
        if _storage._sourceID != rhs_storage._sourceID {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._plateNum != rhs_storage._plateNum {return false}
        if _storage._vehicleClass != rhs_storage._vehicleClass {return false}
        if _storage._fuelType != rhs_storage._fuelType {return false}
        if _storage._brandAndType != rhs_storage._brandAndType {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._accel != rhs_storage._accel {return false}
        if _storage._accelAngle != rhs_storage._accelAngle {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._precision != rhs_storage._precision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PNV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PNV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PnvInfomationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pnvInfomationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pnvInfomationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pnvInfomationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PNV, rhs: NebulalinkProMessage_PNV) -> Bool {
    if lhs.pnvInfomationValue != rhs.pnvInfomationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PNV.PnvInfomation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_PNV.protoMessageName + ".PnvInfomation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "source_type"),
    4: .standard(proto: "source_id"),
    5: .standard(proto: "device_id"),
    6: .same(proto: "longitude"),
    7: .same(proto: "latitude"),
    8: .same(proto: "altitude"),
    9: .same(proto: "speed"),
    10: .same(proto: "heading"),
    11: .same(proto: "accel"),
    12: .standard(proto: "accel_angle"),
    13: .same(proto: "time"),
    14: .same(proto: "precision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sourceType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.sourceID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.deviceID) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.accel) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.accelAngle) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 14: try { try decoder.decodeSingularFloatField(value: &self.precision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    if self.sourceType != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceType, fieldNumber: 3)
    }
    if !self.sourceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sourceID, fieldNumber: 4)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 5)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 6)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 7)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 8)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 9)
    }
    if self.heading != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 10)
    }
    if self.accel != 0 {
      try visitor.visitSingularFloatField(value: self.accel, fieldNumber: 11)
    }
    if self.accelAngle != 0 {
      try visitor.visitSingularFloatField(value: self.accelAngle, fieldNumber: 12)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 13)
    }
    if self.precision != 0 {
      try visitor.visitSingularFloatField(value: self.precision, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PNV.PnvInfomation, rhs: NebulalinkProMessage_PNV.PnvInfomation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.accel != rhs.accel {return false}
    if lhs.accelAngle != rhs.accelAngle {return false}
    if lhs.time != rhs.time {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogicalMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "MapNodeValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mapNodeValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if !self.mapNodeValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapNodeValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap, rhs: NebulalinkProMessage_LogicalMap) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.mapNodeValue != rhs.mapNodeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.protoMessageName + ".MapNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "altitude"),
    4: .same(proto: "name"),
    5: .standard(proto: "node_id"),
    6: .same(proto: "NodeLinkValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nodeID) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.nodeLinkValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 4)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeID, fieldNumber: 5)
    }
    if !self.nodeLinkValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeLinkValue, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode, rhs: NebulalinkProMessage_LogicalMap.MapNode) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.name != rhs.name {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.nodeLinkValue != rhs.nodeLinkValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.protoMessageName + ".NodeLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upstr_node_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "lane_width"),
    4: .same(proto: "LinkSpeedLimitsValue"),
    5: .same(proto: "LinkPointsValue"),
    6: .same(proto: "LinkMovementsValue"),
    7: .same(proto: "LinkLanesValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.upstrNodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.laneWidth) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.linkSpeedLimitsValue) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.linkPointsValue) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.linkMovementsValue) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.linkLanesValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.upstrNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.upstrNodeID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 2)
    }
    if self.laneWidth != 0 {
      try visitor.visitSingularFloatField(value: self.laneWidth, fieldNumber: 3)
    }
    if !self.linkSpeedLimitsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkSpeedLimitsValue, fieldNumber: 4)
    }
    if !self.linkPointsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkPointsValue, fieldNumber: 5)
    }
    if !self.linkMovementsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkMovementsValue, fieldNumber: 6)
    }
    if !self.linkLanesValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkLanesValue, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink) -> Bool {
    if lhs.upstrNodeID != rhs.upstrNodeID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.laneWidth != rhs.laneWidth {return false}
    if lhs.linkSpeedLimitsValue != rhs.linkSpeedLimitsValue {return false}
    if lhs.linkPointsValue != rhs.linkPointsValue {return false}
    if lhs.linkMovementsValue != rhs.linkMovementsValue {return false}
    if lhs.linkLanesValue != rhs.linkLanesValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkSpeedLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.protoMessageName + ".LinkSpeedLimits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_limit_type"),
    2: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.speedLimitType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedLimitType != 0 {
      try visitor.visitSingularInt32Field(value: self.speedLimitType, fieldNumber: 1)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkSpeedLimits, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkSpeedLimits) -> Bool {
    if lhs.speedLimitType != rhs.speedLimitType {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.protoMessageName + ".LinkPoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkPoints, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkPoints) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkMovements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.protoMessageName + ".LinkMovements"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "road_regulator_id"),
    2: .standard(proto: "node_id"),
    3: .standard(proto: "phase_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roadRegulatorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.nodeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.phaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roadRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.roadRegulatorID, fieldNumber: 1)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeID, fieldNumber: 2)
    }
    if self.phaseID != 0 {
      try visitor.visitSingularInt32Field(value: self.phaseID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkMovements, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkMovements) -> Bool {
    if lhs.roadRegulatorID != rhs.roadRegulatorID {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.phaseID != rhs.phaseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.protoMessageName + ".LinkLanes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lane_id"),
    2: .standard(proto: "lane_width"),
    3: .standard(proto: "allowed_maneuvers"),
    4: .standard(proto: "lane_sharing"),
    5: .standard(proto: "lane_attributes_type"),
    6: .same(proto: "LaneSpeedLimitsValue"),
    7: .same(proto: "LaneConnectionsValue"),
    8: .same(proto: "LanePointsValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.laneID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.laneWidth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.allowedManeuvers) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.laneSharing) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.laneAttributesType) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.laneSpeedLimitsValue) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.laneConnectionsValue) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.lanePointsValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.laneID != 0 {
      try visitor.visitSingularInt32Field(value: self.laneID, fieldNumber: 1)
    }
    if self.laneWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.laneWidth, fieldNumber: 2)
    }
    if self.allowedManeuvers != 0 {
      try visitor.visitSingularInt32Field(value: self.allowedManeuvers, fieldNumber: 3)
    }
    if self.laneSharing != 0 {
      try visitor.visitSingularInt32Field(value: self.laneSharing, fieldNumber: 4)
    }
    if self.laneAttributesType != 0 {
      try visitor.visitSingularInt32Field(value: self.laneAttributesType, fieldNumber: 5)
    }
    if !self.laneSpeedLimitsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.laneSpeedLimitsValue, fieldNumber: 6)
    }
    if !self.laneConnectionsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.laneConnectionsValue, fieldNumber: 7)
    }
    if !self.lanePointsValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lanePointsValue, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes) -> Bool {
    if lhs.laneID != rhs.laneID {return false}
    if lhs.laneWidth != rhs.laneWidth {return false}
    if lhs.allowedManeuvers != rhs.allowedManeuvers {return false}
    if lhs.laneSharing != rhs.laneSharing {return false}
    if lhs.laneAttributesType != rhs.laneAttributesType {return false}
    if lhs.laneSpeedLimitsValue != rhs.laneSpeedLimitsValue {return false}
    if lhs.laneConnectionsValue != rhs.laneConnectionsValue {return false}
    if lhs.lanePointsValue != rhs.lanePointsValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneSpeedLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.protoMessageName + ".LaneSpeedLimits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_limit_type"),
    2: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.speedLimitType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedLimitType != 0 {
      try visitor.visitSingularInt32Field(value: self.speedLimitType, fieldNumber: 1)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneSpeedLimits, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneSpeedLimits) -> Bool {
    if lhs.speedLimitType != rhs.speedLimitType {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneConnections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.protoMessageName + ".LaneConnections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "road_regulator_id"),
    2: .standard(proto: "node_id"),
    3: .standard(proto: "lane_id"),
    4: .standard(proto: "allowed_maneuvers"),
    5: .standard(proto: "phase_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roadRegulatorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.nodeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.laneID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.allowedManeuvers) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.phaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roadRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.roadRegulatorID, fieldNumber: 1)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeID, fieldNumber: 2)
    }
    if self.laneID != 0 {
      try visitor.visitSingularInt32Field(value: self.laneID, fieldNumber: 3)
    }
    if self.allowedManeuvers != 0 {
      try visitor.visitSingularInt32Field(value: self.allowedManeuvers, fieldNumber: 4)
    }
    if self.phaseID != 0 {
      try visitor.visitSingularInt32Field(value: self.phaseID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneConnections, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LaneConnections) -> Bool {
    if lhs.roadRegulatorID != rhs.roadRegulatorID {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.laneID != rhs.laneID {return false}
    if lhs.allowedManeuvers != rhs.allowedManeuvers {return false}
    if lhs.phaseID != rhs.phaseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LanePoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.protoMessageName + ".LanePoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LanePoints, rhs: NebulalinkProMessage_LogicalMap.MapNode.NodeLink.LinkLanes.LanePoints) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RtsDataValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rtsDataValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtsDataValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rtsDataValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTS, rhs: NebulalinkProMessage_RTS) -> Bool {
    if lhs.rtsDataValue != rhs.rtsDataValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTS.RtsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTS.protoMessageName + ".RtsData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rts_id"),
    2: .standard(proto: "rts_type"),
    3: .standard(proto: "rts_longitude"),
    4: .standard(proto: "rts_latitude"),
    5: .standard(proto: "rts_altitude"),
    6: .standard(proto: "rts_description"),
    7: .standard(proto: "rts_start_time"),
    8: .standard(proto: "rts_end_time"),
    9: .standard(proto: "rts_priority"),
    10: .standard(proto: "rsu_longitude"),
    11: .standard(proto: "rsu_latitude"),
    12: .standard(proto: "rsu_altitude"),
    13: .standard(proto: "rsu_time"),
    14: .standard(proto: "rsu_id"),
    15: .same(proto: "RtsPathInformationValue"),
    16: .same(proto: "RtsLinkInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rtsID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rtsType) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.rtsLongitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.rtsLatitude) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.rtsAltitude) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.rtsDescription) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.rtsStartTime) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.rtsEndTime) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.rtsPriority) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.rsuLongitude) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.rsuLatitude) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self.rsuAltitude) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.rsuTime) }()
      case 14: try { try decoder.decodeSingularBytesField(value: &self.rsuID) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.rtsPathInformationValue) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.rtsLinkInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rtsID != 0 {
      try visitor.visitSingularInt32Field(value: self.rtsID, fieldNumber: 1)
    }
    if self.rtsType != 0 {
      try visitor.visitSingularInt32Field(value: self.rtsType, fieldNumber: 2)
    }
    if self.rtsLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rtsLongitude, fieldNumber: 3)
    }
    if self.rtsLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rtsLatitude, fieldNumber: 4)
    }
    if self.rtsAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rtsAltitude, fieldNumber: 5)
    }
    if !self.rtsDescription.isEmpty {
      try visitor.visitSingularBytesField(value: self.rtsDescription, fieldNumber: 6)
    }
    if self.rtsStartTime != 0 {
      try visitor.visitSingularInt64Field(value: self.rtsStartTime, fieldNumber: 7)
    }
    if self.rtsEndTime != 0 {
      try visitor.visitSingularInt64Field(value: self.rtsEndTime, fieldNumber: 8)
    }
    if self.rtsPriority != 0 {
      try visitor.visitSingularInt32Field(value: self.rtsPriority, fieldNumber: 9)
    }
    if self.rsuLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rsuLongitude, fieldNumber: 10)
    }
    if self.rsuLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rsuLatitude, fieldNumber: 11)
    }
    if self.rsuAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.rsuAltitude, fieldNumber: 12)
    }
    if self.rsuTime != 0 {
      try visitor.visitSingularInt64Field(value: self.rsuTime, fieldNumber: 13)
    }
    if !self.rsuID.isEmpty {
      try visitor.visitSingularBytesField(value: self.rsuID, fieldNumber: 14)
    }
    if !self.rtsPathInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rtsPathInformationValue, fieldNumber: 15)
    }
    if !self.rtsLinkInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rtsLinkInformationValue, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTS.RtsData, rhs: NebulalinkProMessage_RTS.RtsData) -> Bool {
    if lhs.rtsID != rhs.rtsID {return false}
    if lhs.rtsType != rhs.rtsType {return false}
    if lhs.rtsLongitude != rhs.rtsLongitude {return false}
    if lhs.rtsLatitude != rhs.rtsLatitude {return false}
    if lhs.rtsAltitude != rhs.rtsAltitude {return false}
    if lhs.rtsDescription != rhs.rtsDescription {return false}
    if lhs.rtsStartTime != rhs.rtsStartTime {return false}
    if lhs.rtsEndTime != rhs.rtsEndTime {return false}
    if lhs.rtsPriority != rhs.rtsPriority {return false}
    if lhs.rsuLongitude != rhs.rsuLongitude {return false}
    if lhs.rsuLatitude != rhs.rsuLatitude {return false}
    if lhs.rsuAltitude != rhs.rsuAltitude {return false}
    if lhs.rsuTime != rhs.rsuTime {return false}
    if lhs.rsuID != rhs.rsuID {return false}
    if lhs.rtsPathInformationValue != rhs.rtsPathInformationValue {return false}
    if lhs.rtsLinkInformationValue != rhs.rtsLinkInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTS.RtsData.RtsPathInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTS.RtsData.protoMessageName + ".RtsPathInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_radius"),
    2: .same(proto: "PathPointInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.pathRadius) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pathPointInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathRadius != 0 {
      try visitor.visitSingularFloatField(value: self.pathRadius, fieldNumber: 1)
    }
    if !self.pathPointInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathPointInformationValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTS.RtsData.RtsPathInformation, rhs: NebulalinkProMessage_RTS.RtsData.RtsPathInformation) -> Bool {
    if lhs.pathRadius != rhs.pathRadius {return false}
    if lhs.pathPointInformationValue != rhs.pathPointInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTS.RtsData.RtsPathInformation.PathPointInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTS.RtsData.RtsPathInformation.protoMessageName + ".PathPointInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_longitude"),
    2: .standard(proto: "point_latitude"),
    3: .standard(proto: "point_altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.pointLongitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pointLatitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pointAltitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pointLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLongitude, fieldNumber: 1)
    }
    if self.pointLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLatitude, fieldNumber: 2)
    }
    if self.pointAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointAltitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTS.RtsData.RtsPathInformation.PathPointInformation, rhs: NebulalinkProMessage_RTS.RtsData.RtsPathInformation.PathPointInformation) -> Bool {
    if lhs.pointLongitude != rhs.pointLongitude {return false}
    if lhs.pointLatitude != rhs.pointLatitude {return false}
    if lhs.pointAltitude != rhs.pointAltitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTS.RtsData.RtsLinkInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTS.RtsData.protoMessageName + ".RtsLinkInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "up_regulator_id"),
    2: .standard(proto: "up_node_id"),
    3: .standard(proto: "down_regulator_id"),
    4: .standard(proto: "down_node_id"),
    5: .same(proto: "lanes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.upRegulatorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.upNodeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.downRegulatorID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.downNodeID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.lanes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.upRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.upRegulatorID, fieldNumber: 1)
    }
    if self.upNodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.upNodeID, fieldNumber: 2)
    }
    if self.downRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.downRegulatorID, fieldNumber: 3)
    }
    if self.downNodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.downNodeID, fieldNumber: 4)
    }
    if self.lanes != 0 {
      try visitor.visitSingularInt32Field(value: self.lanes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTS.RtsData.RtsLinkInformation, rhs: NebulalinkProMessage_RTS.RtsData.RtsLinkInformation) -> Bool {
    if lhs.upRegulatorID != rhs.upRegulatorID {return false}
    if lhs.upNodeID != rhs.upNodeID {return false}
    if lhs.downRegulatorID != rhs.downRegulatorID {return false}
    if lhs.downNodeID != rhs.downNodeID {return false}
    if lhs.lanes != rhs.lanes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTE: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTE"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RteDataValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rteDataValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rteDataValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rteDataValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTE, rhs: NebulalinkProMessage_RTE) -> Bool {
    if lhs.rteDataValue != rhs.rteDataValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTE.RteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTE.protoMessageName + ".RteData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rte_id"),
    2: .standard(proto: "rte_type"),
    3: .standard(proto: "rte_source"),
    4: .standard(proto: "rte_longitude"),
    5: .standard(proto: "rte_latitude"),
    6: .standard(proto: "rte_altitude"),
    7: .standard(proto: "rte_radius"),
    8: .standard(proto: "rte_description"),
    9: .standard(proto: "rte_start_time"),
    10: .standard(proto: "rte_end_time"),
    11: .standard(proto: "rte_priority"),
    12: .standard(proto: "rsu_longitude"),
    13: .standard(proto: "rsu_latitude"),
    14: .standard(proto: "rsu_altitude"),
    15: .standard(proto: "rsu_time"),
    16: .standard(proto: "rsu_id"),
    17: .same(proto: "RtePathInformationValue"),
    18: .same(proto: "RteLinkInformationValue"),
  ]

  fileprivate class _StorageClass {
    var _rteID: Int32 = 0
    var _rteType: Int32 = 0
    var _rteSource: Int32 = 0
    var _rteLongitude: Double = 0
    var _rteLatitude: Double = 0
    var _rteAltitude: Double = 0
    var _rteRadius: Float = 0
    var _rteDescription: Data = Data()
    var _rteStartTime: Int64 = 0
    var _rteEndTime: Int64 = 0
    var _rtePriority: Int32 = 0
    var _rsuLongitude: Double = 0
    var _rsuLatitude: Double = 0
    var _rsuAltitude: Double = 0
    var _rsuTime: Int64 = 0
    var _rsuID: Data = Data()
    var _rtePathInformationValue: [NebulalinkProMessage_RTE.RteData.RtePathInformation] = []
    var _rteLinkInformationValue: [NebulalinkProMessage_RTE.RteData.RteLinkInformation] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rteID = source._rteID
      _rteType = source._rteType
      _rteSource = source._rteSource
      _rteLongitude = source._rteLongitude
      _rteLatitude = source._rteLatitude
      _rteAltitude = source._rteAltitude
      _rteRadius = source._rteRadius
      _rteDescription = source._rteDescription
      _rteStartTime = source._rteStartTime
      _rteEndTime = source._rteEndTime
      _rtePriority = source._rtePriority
      _rsuLongitude = source._rsuLongitude
      _rsuLatitude = source._rsuLatitude
      _rsuAltitude = source._rsuAltitude
      _rsuTime = source._rsuTime
      _rsuID = source._rsuID
      _rtePathInformationValue = source._rtePathInformationValue
      _rteLinkInformationValue = source._rteLinkInformationValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._rteID) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._rteType) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._rteSource) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._rteLongitude) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._rteLatitude) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._rteAltitude) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._rteRadius) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._rteDescription) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._rteStartTime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._rteEndTime) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._rtePriority) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._rsuLongitude) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._rsuLatitude) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._rsuAltitude) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._rsuTime) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._rsuID) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._rtePathInformationValue) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._rteLinkInformationValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._rteID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rteID, fieldNumber: 1)
      }
      if _storage._rteType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rteType, fieldNumber: 2)
      }
      if _storage._rteSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rteSource, fieldNumber: 3)
      }
      if _storage._rteLongitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rteLongitude, fieldNumber: 4)
      }
      if _storage._rteLatitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rteLatitude, fieldNumber: 5)
      }
      if _storage._rteAltitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rteAltitude, fieldNumber: 6)
      }
      if _storage._rteRadius != 0 {
        try visitor.visitSingularFloatField(value: _storage._rteRadius, fieldNumber: 7)
      }
      if !_storage._rteDescription.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rteDescription, fieldNumber: 8)
      }
      if _storage._rteStartTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rteStartTime, fieldNumber: 9)
      }
      if _storage._rteEndTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rteEndTime, fieldNumber: 10)
      }
      if _storage._rtePriority != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rtePriority, fieldNumber: 11)
      }
      if _storage._rsuLongitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rsuLongitude, fieldNumber: 12)
      }
      if _storage._rsuLatitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rsuLatitude, fieldNumber: 13)
      }
      if _storage._rsuAltitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rsuAltitude, fieldNumber: 14)
      }
      if _storage._rsuTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rsuTime, fieldNumber: 15)
      }
      if !_storage._rsuID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rsuID, fieldNumber: 16)
      }
      if !_storage._rtePathInformationValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rtePathInformationValue, fieldNumber: 17)
      }
      if !_storage._rteLinkInformationValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rteLinkInformationValue, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTE.RteData, rhs: NebulalinkProMessage_RTE.RteData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rteID != rhs_storage._rteID {return false}
        if _storage._rteType != rhs_storage._rteType {return false}
        if _storage._rteSource != rhs_storage._rteSource {return false}
        if _storage._rteLongitude != rhs_storage._rteLongitude {return false}
        if _storage._rteLatitude != rhs_storage._rteLatitude {return false}
        if _storage._rteAltitude != rhs_storage._rteAltitude {return false}
        if _storage._rteRadius != rhs_storage._rteRadius {return false}
        if _storage._rteDescription != rhs_storage._rteDescription {return false}
        if _storage._rteStartTime != rhs_storage._rteStartTime {return false}
        if _storage._rteEndTime != rhs_storage._rteEndTime {return false}
        if _storage._rtePriority != rhs_storage._rtePriority {return false}
        if _storage._rsuLongitude != rhs_storage._rsuLongitude {return false}
        if _storage._rsuLatitude != rhs_storage._rsuLatitude {return false}
        if _storage._rsuAltitude != rhs_storage._rsuAltitude {return false}
        if _storage._rsuTime != rhs_storage._rsuTime {return false}
        if _storage._rsuID != rhs_storage._rsuID {return false}
        if _storage._rtePathInformationValue != rhs_storage._rtePathInformationValue {return false}
        if _storage._rteLinkInformationValue != rhs_storage._rteLinkInformationValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTE.RteData.RtePathInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTE.RteData.protoMessageName + ".RtePathInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_radius"),
    2: .same(proto: "PathPointInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.pathRadius) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pathPointInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathRadius != 0 {
      try visitor.visitSingularFloatField(value: self.pathRadius, fieldNumber: 1)
    }
    if !self.pathPointInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathPointInformationValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTE.RteData.RtePathInformation, rhs: NebulalinkProMessage_RTE.RteData.RtePathInformation) -> Bool {
    if lhs.pathRadius != rhs.pathRadius {return false}
    if lhs.pathPointInformationValue != rhs.pathPointInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTE.RteData.RtePathInformation.PathPointInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTE.RteData.RtePathInformation.protoMessageName + ".PathPointInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_longitude"),
    2: .standard(proto: "point_latitude"),
    3: .standard(proto: "point_altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.pointLongitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pointLatitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pointAltitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pointLongitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLongitude, fieldNumber: 1)
    }
    if self.pointLatitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointLatitude, fieldNumber: 2)
    }
    if self.pointAltitude != 0 {
      try visitor.visitSingularDoubleField(value: self.pointAltitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTE.RteData.RtePathInformation.PathPointInformation, rhs: NebulalinkProMessage_RTE.RteData.RtePathInformation.PathPointInformation) -> Bool {
    if lhs.pointLongitude != rhs.pointLongitude {return false}
    if lhs.pointLatitude != rhs.pointLatitude {return false}
    if lhs.pointAltitude != rhs.pointAltitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RTE.RteData.RteLinkInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RTE.RteData.protoMessageName + ".RteLinkInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "up_regulator_id"),
    2: .standard(proto: "up_node_id"),
    3: .standard(proto: "down_regulator_id"),
    4: .standard(proto: "down_node_id"),
    5: .same(proto: "lanes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.upRegulatorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.upNodeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.downRegulatorID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.downNodeID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.lanes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.upRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.upRegulatorID, fieldNumber: 1)
    }
    if self.upNodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.upNodeID, fieldNumber: 2)
    }
    if self.downRegulatorID != 0 {
      try visitor.visitSingularInt32Field(value: self.downRegulatorID, fieldNumber: 3)
    }
    if self.downNodeID != 0 {
      try visitor.visitSingularInt32Field(value: self.downNodeID, fieldNumber: 4)
    }
    if self.lanes != 0 {
      try visitor.visitSingularInt32Field(value: self.lanes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RTE.RteData.RteLinkInformation, rhs: NebulalinkProMessage_RTE.RteData.RteLinkInformation) -> Bool {
    if lhs.upRegulatorID != rhs.upRegulatorID {return false}
    if lhs.upNodeID != rhs.upNodeID {return false}
    if lhs.downRegulatorID != rhs.downRegulatorID {return false}
    if lhs.downNodeID != rhs.downNodeID {return false}
    if lhs.lanes != rhs.lanes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficLight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TrafficLightInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trafficLightInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trafficLightInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficLightInformationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLight, rhs: NebulalinkProMessage_TrafficLight) -> Bool {
    if lhs.trafficLightInformationValue != rhs.trafficLightInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLight.TrafficLightInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficLight.protoMessageName + ".TrafficLightInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .standard(proto: "intersection_region_node_id"),
    3: .same(proto: "status"),
    4: .same(proto: "time"),
    5: .standard(proto: "time_confidence"),
    6: .same(proto: "TrafficLightPhaseValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.description_p) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.intersectionRegionNodeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.timeConfidence) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.trafficLightPhaseValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 1)
    }
    if self.intersectionRegionNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.intersectionRegionNodeID, fieldNumber: 2)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 4)
    }
    if self.timeConfidence != 0 {
      try visitor.visitSingularInt32Field(value: self.timeConfidence, fieldNumber: 5)
    }
    if !self.trafficLightPhaseValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficLightPhaseValue, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation, rhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.intersectionRegionNodeID != rhs.intersectionRegionNodeID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.time != rhs.time {return false}
    if lhs.timeConfidence != rhs.timeConfidence {return false}
    if lhs.trafficLightPhaseValue != rhs.trafficLightPhaseValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficLight.TrafficLightInformation.protoMessageName + ".TrafficLightPhase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phase_id"),
    2: .same(proto: "PhaseStatusValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.phaseID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.phaseStatusValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.phaseID != 0 {
      try visitor.visitSingularInt32Field(value: self.phaseID, fieldNumber: 1)
    }
    if !self.phaseStatusValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phaseStatusValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase, rhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase) -> Bool {
    if lhs.phaseID != rhs.phaseID {return false}
    if lhs.phaseStatusValue != rhs.phaseStatusValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase.PhaseStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase.protoMessageName + ".PhaseStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "light_status"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "min_end_time"),
    4: .standard(proto: "max_end_time"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "time_confidence"),
    7: .standard(proto: "next_start_time"),
    8: .standard(proto: "next_cycle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.lightStatus) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.minEndTime) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.maxEndTime) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.endTime) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.timeConfidence) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.nextStartTime) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.nextCycle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lightStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lightStatus, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularFloatField(value: self.startTime, fieldNumber: 2)
    }
    if self.minEndTime != 0 {
      try visitor.visitSingularFloatField(value: self.minEndTime, fieldNumber: 3)
    }
    if self.maxEndTime != 0 {
      try visitor.visitSingularFloatField(value: self.maxEndTime, fieldNumber: 4)
    }
    if self.endTime != 0 {
      try visitor.visitSingularFloatField(value: self.endTime, fieldNumber: 5)
    }
    if self.timeConfidence != 0 {
      try visitor.visitSingularInt32Field(value: self.timeConfidence, fieldNumber: 6)
    }
    if self.nextStartTime != 0 {
      try visitor.visitSingularFloatField(value: self.nextStartTime, fieldNumber: 7)
    }
    if self.nextCycle != 0 {
      try visitor.visitSingularFloatField(value: self.nextCycle, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase.PhaseStatus, rhs: NebulalinkProMessage_TrafficLight.TrafficLightInformation.TrafficLightPhase.PhaseStatus) -> Bool {
    if lhs.lightStatus != rhs.lightStatus {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.minEndTime != rhs.minEndTime {return false}
    if lhs.maxEndTime != rhs.maxEndTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.timeConfidence != rhs.timeConfidence {return false}
    if lhs.nextStartTime != rhs.nextStartTime {return false}
    if lhs.nextCycle != rhs.nextCycle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficSignalPlan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TrafficSignalValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trafficSignalValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trafficSignalValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficSignalValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlan, rhs: NebulalinkProMessage_TrafficSignalPlan) -> Bool {
    if lhs.trafficSignalValue != rhs.trafficSignalValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlan.TrafficSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficSignalPlan.protoMessageName + ".TrafficSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signal_name"),
    2: .standard(proto: "intersection_region_node_id"),
    3: .standard(proto: "signal_offset"),
    4: .standard(proto: "sync_time"),
    5: .same(proto: "status"),
    6: .standard(proto: "time_zone"),
    7: .same(proto: "TrafficSignalPlanInfoValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signalName) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.intersectionRegionNodeID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.signalOffset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.syncTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.timeZone) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.trafficSignalPlanInfoValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signalName.isEmpty {
      try visitor.visitSingularBytesField(value: self.signalName, fieldNumber: 1)
    }
    if self.intersectionRegionNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.intersectionRegionNodeID, fieldNumber: 2)
    }
    if self.signalOffset != 0 {
      try visitor.visitSingularFloatField(value: self.signalOffset, fieldNumber: 3)
    }
    if self.syncTime != 0 {
      try visitor.visitSingularInt32Field(value: self.syncTime, fieldNumber: 4)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 5)
    }
    if self.timeZone != 0 {
      try visitor.visitSingularInt32Field(value: self.timeZone, fieldNumber: 6)
    }
    if !self.trafficSignalPlanInfoValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficSignalPlanInfoValue, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal, rhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal) -> Bool {
    if lhs.signalName != rhs.signalName {return false}
    if lhs.intersectionRegionNodeID != rhs.intersectionRegionNodeID {return false}
    if lhs.signalOffset != rhs.signalOffset {return false}
    if lhs.syncTime != rhs.syncTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.trafficSignalPlanInfoValue != rhs.trafficSignalPlanInfoValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.protoMessageName + ".TrafficSignalPlanInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "plan_name"),
    2: .standard(proto: "plan_id"),
    3: .standard(proto: "start_tim"),
    4: .standard(proto: "end_time"),
    5: .same(proto: "cycle"),
    6: .same(proto: "offset"),
    7: .standard(proto: "reference_phase_1"),
    8: .standard(proto: "reference_phase_2"),
    9: .standard(proto: "reference_phase_3"),
    10: .standard(proto: "reference_phase_4"),
    11: .standard(proto: "reference_type"),
    12: .same(proto: "TrafficSignalPlanPhaseValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.planName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.planID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startTim) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.cycle) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.referencePhase1) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.referencePhase2) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.referencePhase3) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.referencePhase4) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.referenceType) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.trafficSignalPlanPhaseValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.planName.isEmpty {
      try visitor.visitSingularBytesField(value: self.planName, fieldNumber: 1)
    }
    if self.planID != 0 {
      try visitor.visitSingularInt32Field(value: self.planID, fieldNumber: 2)
    }
    if self.startTim != 0 {
      try visitor.visitSingularInt32Field(value: self.startTim, fieldNumber: 3)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 4)
    }
    if self.cycle != 0 {
      try visitor.visitSingularFloatField(value: self.cycle, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularFloatField(value: self.offset, fieldNumber: 6)
    }
    if self.referencePhase1 != 0 {
      try visitor.visitSingularInt32Field(value: self.referencePhase1, fieldNumber: 7)
    }
    if self.referencePhase2 != 0 {
      try visitor.visitSingularInt32Field(value: self.referencePhase2, fieldNumber: 8)
    }
    if self.referencePhase3 != 0 {
      try visitor.visitSingularInt32Field(value: self.referencePhase3, fieldNumber: 9)
    }
    if self.referencePhase4 != 0 {
      try visitor.visitSingularInt32Field(value: self.referencePhase4, fieldNumber: 10)
    }
    if !self.referenceType.isEmpty {
      try visitor.visitSingularBytesField(value: self.referenceType, fieldNumber: 11)
    }
    if !self.trafficSignalPlanPhaseValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficSignalPlanPhaseValue, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo, rhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo) -> Bool {
    if lhs.planName != rhs.planName {return false}
    if lhs.planID != rhs.planID {return false}
    if lhs.startTim != rhs.startTim {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.cycle != rhs.cycle {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.referencePhase1 != rhs.referencePhase1 {return false}
    if lhs.referencePhase2 != rhs.referencePhase2 {return false}
    if lhs.referencePhase3 != rhs.referencePhase3 {return false}
    if lhs.referencePhase4 != rhs.referencePhase4 {return false}
    if lhs.referenceType != rhs.referenceType {return false}
    if lhs.trafficSignalPlanPhaseValue != rhs.trafficSignalPlanPhaseValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo.TrafficSignalPlanPhase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo.protoMessageName + ".TrafficSignalPlanPhase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phase_id"),
    2: .standard(proto: "local_start"),
    3: .standard(proto: "pre_green"),
    4: .same(proto: "green"),
    5: .standard(proto: "min_green"),
    6: .standard(proto: "max_green"),
    7: .same(proto: "yellow"),
    8: .standard(proto: "yellow_flash"),
    9: .same(proto: "red"),
    10: .standard(proto: "red_flash"),
    11: .standard(proto: "ped_green"),
    12: .standard(proto: "ped_green_flash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.phaseID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.localStart) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.preGreen) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.green) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.minGreen) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.maxGreen) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.yellow) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.yellowFlash) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.red) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.redFlash) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.pedGreen) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.pedGreenFlash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.phaseID != 0 {
      try visitor.visitSingularInt32Field(value: self.phaseID, fieldNumber: 1)
    }
    if self.localStart != 0 {
      try visitor.visitSingularFloatField(value: self.localStart, fieldNumber: 2)
    }
    if self.preGreen != 0 {
      try visitor.visitSingularFloatField(value: self.preGreen, fieldNumber: 3)
    }
    if self.green != 0 {
      try visitor.visitSingularFloatField(value: self.green, fieldNumber: 4)
    }
    if self.minGreen != 0 {
      try visitor.visitSingularFloatField(value: self.minGreen, fieldNumber: 5)
    }
    if self.maxGreen != 0 {
      try visitor.visitSingularFloatField(value: self.maxGreen, fieldNumber: 6)
    }
    if self.yellow != 0 {
      try visitor.visitSingularFloatField(value: self.yellow, fieldNumber: 7)
    }
    if self.yellowFlash != 0 {
      try visitor.visitSingularFloatField(value: self.yellowFlash, fieldNumber: 8)
    }
    if self.red != 0 {
      try visitor.visitSingularFloatField(value: self.red, fieldNumber: 9)
    }
    if self.redFlash != 0 {
      try visitor.visitSingularFloatField(value: self.redFlash, fieldNumber: 10)
    }
    if self.pedGreen != 0 {
      try visitor.visitSingularFloatField(value: self.pedGreen, fieldNumber: 11)
    }
    if self.pedGreenFlash != 0 {
      try visitor.visitSingularFloatField(value: self.pedGreenFlash, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo.TrafficSignalPlanPhase, rhs: NebulalinkProMessage_TrafficSignalPlan.TrafficSignal.TrafficSignalPlanInfo.TrafficSignalPlanPhase) -> Bool {
    if lhs.phaseID != rhs.phaseID {return false}
    if lhs.localStart != rhs.localStart {return false}
    if lhs.preGreen != rhs.preGreen {return false}
    if lhs.green != rhs.green {return false}
    if lhs.minGreen != rhs.minGreen {return false}
    if lhs.maxGreen != rhs.maxGreen {return false}
    if lhs.yellow != rhs.yellow {return false}
    if lhs.yellowFlash != rhs.yellowFlash {return false}
    if lhs.red != rhs.red {return false}
    if lhs.redFlash != rhs.redFlash {return false}
    if lhs.pedGreen != rhs.pedGreen {return false}
    if lhs.pedGreenFlash != rhs.pedGreenFlash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlanOffset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficSignalPlanOffset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TrafficSignalValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trafficSignalValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trafficSignalValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficSignalValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlanOffset, rhs: NebulalinkProMessage_TrafficSignalPlanOffset) -> Bool {
    if lhs.trafficSignalValue != rhs.trafficSignalValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficSignalPlanOffset.TrafficSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficSignalPlanOffset.protoMessageName + ".TrafficSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intersection_region_node_id"),
    2: .standard(proto: "signal_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.intersectionRegionNodeID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.signalOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.intersectionRegionNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.intersectionRegionNodeID, fieldNumber: 1)
    }
    if self.signalOffset != 0 {
      try visitor.visitSingularFloatField(value: self.signalOffset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficSignalPlanOffset.TrafficSignal, rhs: NebulalinkProMessage_TrafficSignalPlanOffset.TrafficSignal) -> Bool {
    if lhs.intersectionRegionNodeID != rhs.intersectionRegionNodeID {return false}
    if lhs.signalOffset != rhs.signalOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_WarningTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WarningTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WarningResultValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.warningResultValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.warningResultValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.warningResultValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_WarningTarget, rhs: NebulalinkProMessage_WarningTarget) -> Bool {
    if lhs.warningResultValue != rhs.warningResultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_WarningTarget.WarningResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_WarningTarget.protoMessageName + ".WarningResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "warning_event_type"),
    2: .standard(proto: "target_type"),
    3: .standard(proto: "target_angle"),
    4: .standard(proto: "target_distance"),
    5: .standard(proto: "target_vehicle_type"),
    6: .standard(proto: "target_vehicle_fuel"),
    7: .standard(proto: "target_vehicle_brand"),
    8: .same(proto: "ttc"),
    9: .standard(proto: "warning_type"),
    10: .same(proto: "longitude"),
    11: .same(proto: "latitude"),
    12: .same(proto: "altitude"),
    13: .same(proto: "speed"),
    14: .same(proto: "heading"),
    15: .same(proto: "accel"),
    16: .standard(proto: "accel_angle"),
    17: .same(proto: "time"),
    18: .standard(proto: "local_id"),
  ]

  fileprivate class _StorageClass {
    var _warningEventType: Int32 = 0
    var _targetType: Int32 = 0
    var _targetAngle: Double = 0
    var _targetDistance: Double = 0
    var _targetVehicleType: Int32 = 0
    var _targetVehicleFuel: Int32 = 0
    var _targetVehicleBrand: Data = Data()
    var _ttc: Double = 0
    var _warningType: Int32 = 0
    var _longitude: Double = 0
    var _latitude: Double = 0
    var _altitude: Double = 0
    var _speed: Float = 0
    var _heading: Float = 0
    var _accel: Float = 0
    var _accelAngle: Float = 0
    var _time: Int64 = 0
    var _localID: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _warningEventType = source._warningEventType
      _targetType = source._targetType
      _targetAngle = source._targetAngle
      _targetDistance = source._targetDistance
      _targetVehicleType = source._targetVehicleType
      _targetVehicleFuel = source._targetVehicleFuel
      _targetVehicleBrand = source._targetVehicleBrand
      _ttc = source._ttc
      _warningType = source._warningType
      _longitude = source._longitude
      _latitude = source._latitude
      _altitude = source._altitude
      _speed = source._speed
      _heading = source._heading
      _accel = source._accel
      _accelAngle = source._accelAngle
      _time = source._time
      _localID = source._localID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._warningEventType) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._targetType) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._targetAngle) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._targetDistance) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._targetVehicleType) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._targetVehicleFuel) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._targetVehicleBrand) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._ttc) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._warningType) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._longitude) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._latitude) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._altitude) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._speed) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._heading) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._accel) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._accelAngle) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._localID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._warningEventType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._warningEventType, fieldNumber: 1)
      }
      if _storage._targetType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetType, fieldNumber: 2)
      }
      if _storage._targetAngle != 0 {
        try visitor.visitSingularDoubleField(value: _storage._targetAngle, fieldNumber: 3)
      }
      if _storage._targetDistance != 0 {
        try visitor.visitSingularDoubleField(value: _storage._targetDistance, fieldNumber: 4)
      }
      if _storage._targetVehicleType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetVehicleType, fieldNumber: 5)
      }
      if _storage._targetVehicleFuel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetVehicleFuel, fieldNumber: 6)
      }
      if !_storage._targetVehicleBrand.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._targetVehicleBrand, fieldNumber: 7)
      }
      if _storage._ttc != 0 {
        try visitor.visitSingularDoubleField(value: _storage._ttc, fieldNumber: 8)
      }
      if _storage._warningType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._warningType, fieldNumber: 9)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._longitude, fieldNumber: 10)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latitude, fieldNumber: 11)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._altitude, fieldNumber: 12)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularFloatField(value: _storage._speed, fieldNumber: 13)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularFloatField(value: _storage._heading, fieldNumber: 14)
      }
      if _storage._accel != 0 {
        try visitor.visitSingularFloatField(value: _storage._accel, fieldNumber: 15)
      }
      if _storage._accelAngle != 0 {
        try visitor.visitSingularFloatField(value: _storage._accelAngle, fieldNumber: 16)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 17)
      }
      if _storage._localID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._localID, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_WarningTarget.WarningResult, rhs: NebulalinkProMessage_WarningTarget.WarningResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._warningEventType != rhs_storage._warningEventType {return false}
        if _storage._targetType != rhs_storage._targetType {return false}
        if _storage._targetAngle != rhs_storage._targetAngle {return false}
        if _storage._targetDistance != rhs_storage._targetDistance {return false}
        if _storage._targetVehicleType != rhs_storage._targetVehicleType {return false}
        if _storage._targetVehicleFuel != rhs_storage._targetVehicleFuel {return false}
        if _storage._targetVehicleBrand != rhs_storage._targetVehicleBrand {return false}
        if _storage._ttc != rhs_storage._ttc {return false}
        if _storage._warningType != rhs_storage._warningType {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._accel != rhs_storage._accel {return false}
        if _storage._accelAngle != rhs_storage._accelAngle {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._localID != rhs_storage._localID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_MapResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_id"),
    2: .standard(proto: "to_node_id"),
    3: .standard(proto: "dis_to_end"),
    4: .standard(proto: "lane_id"),
    5: .standard(proto: "link_id"),
    6: .standard(proto: "speed_upper_limit"),
    7: .standard(proto: "speed_floor_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fromNodeID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.toNodeID) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.disToEnd) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.laneID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.linkID) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.speedUpperLimit) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.speedFloorLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.fromNodeID, fieldNumber: 1)
    }
    if self.toNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.toNodeID, fieldNumber: 2)
    }
    if self.disToEnd != 0 {
      try visitor.visitSingularDoubleField(value: self.disToEnd, fieldNumber: 3)
    }
    if self.laneID != 0 {
      try visitor.visitSingularInt32Field(value: self.laneID, fieldNumber: 4)
    }
    if self.linkID != 0 {
      try visitor.visitSingularInt32Field(value: self.linkID, fieldNumber: 5)
    }
    if self.speedUpperLimit != 0 {
      try visitor.visitSingularFloatField(value: self.speedUpperLimit, fieldNumber: 6)
    }
    if self.speedFloorLimit != 0 {
      try visitor.visitSingularFloatField(value: self.speedFloorLimit, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_MapResult, rhs: NebulalinkProMessage_MapResult) -> Bool {
    if lhs.fromNodeID != rhs.fromNodeID {return false}
    if lhs.toNodeID != rhs.toNodeID {return false}
    if lhs.disToEnd != rhs.disToEnd {return false}
    if lhs.laneID != rhs.laneID {return false}
    if lhs.linkID != rhs.linkID {return false}
    if lhs.speedUpperLimit != rhs.speedUpperLimit {return false}
    if lhs.speedFloorLimit != rhs.speedFloorLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RtsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RtsResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RtsResultInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rtsResultInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtsResultInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rtsResultInformationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RtsResult, rhs: NebulalinkProMessage_RtsResult) -> Bool {
    if lhs.rtsResultInformationValue != rhs.rtsResultInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RtsResult.RtsResultInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RtsResult.protoMessageName + ".RtsResultInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "description"),
    3: .standard(proto: "dis_to_end"),
    4: .standard(proto: "rdis_to_path"),
    5: .standard(proto: "upper_node_id"),
    6: .standard(proto: "down_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.disToEnd) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.rdisToPath) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.upperNodeID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.downNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 2)
    }
    if self.disToEnd != 0 {
      try visitor.visitSingularDoubleField(value: self.disToEnd, fieldNumber: 3)
    }
    if self.rdisToPath != 0 {
      try visitor.visitSingularDoubleField(value: self.rdisToPath, fieldNumber: 4)
    }
    if self.upperNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.upperNodeID, fieldNumber: 5)
    }
    if self.downNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.downNodeID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RtsResult.RtsResultInformation, rhs: NebulalinkProMessage_RtsResult.RtsResultInformation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.disToEnd != rhs.disToEnd {return false}
    if lhs.rdisToPath != rhs.rdisToPath {return false}
    if lhs.upperNodeID != rhs.upperNodeID {return false}
    if lhs.downNodeID != rhs.downNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RteResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RteResultInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rteResultInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rteResultInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rteResultInformationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RteResult, rhs: NebulalinkProMessage_RteResult) -> Bool {
    if lhs.rteResultInformationValue != rhs.rteResultInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_RteResult.RteResultInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_RteResult.protoMessageName + ".RteResultInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    3: .same(proto: "description"),
    4: .standard(proto: "dis_to_end"),
    5: .standard(proto: "rdis_to_path"),
    6: .standard(proto: "upper_node_id"),
    7: .standard(proto: "down_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.source) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.disToEnd) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.rdisToPath) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.upperNodeID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.downNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if self.source != 0 {
      try visitor.visitSingularInt32Field(value: self.source, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 3)
    }
    if self.disToEnd != 0 {
      try visitor.visitSingularDoubleField(value: self.disToEnd, fieldNumber: 4)
    }
    if self.rdisToPath != 0 {
      try visitor.visitSingularDoubleField(value: self.rdisToPath, fieldNumber: 5)
    }
    if self.upperNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.upperNodeID, fieldNumber: 6)
    }
    if self.downNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.downNodeID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_RteResult.RteResultInformation, rhs: NebulalinkProMessage_RteResult.RteResultInformation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.source != rhs.source {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.disToEnd != rhs.disToEnd {return false}
    if lhs.rdisToPath != rhs.rdisToPath {return false}
    if lhs.upperNodeID != rhs.upperNodeID {return false}
    if lhs.downNodeID != rhs.downNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLightResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficLightResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TrafficLightResultInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trafficLightResultInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trafficLightResultInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trafficLightResultInformationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLightResult, rhs: NebulalinkProMessage_TrafficLightResult) -> Bool {
    if lhs.trafficLightResultInformationValue != rhs.trafficLightResultInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TrafficLightResult.TrafficLightResultInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_TrafficLightResult.protoMessageName + ".TrafficLightResultInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "turner_angle"),
    2: .same(proto: "direction"),
    3: .standard(proto: "light_state"),
    4: .standard(proto: "time_remaining"),
    5: .standard(proto: "rec_upper_speed"),
    6: .standard(proto: "rec_floor_speed"),
    7: .standard(proto: "direction_node_id"),
    8: .standard(proto: "phase_id"),
    9: .standard(proto: "decel_red_break"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.turnerAngle) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lightState) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.timeRemaining) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.recUpperSpeed) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.recFloorSpeed) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.directionNodeID) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.phaseID) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.decelRedBreak) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.turnerAngle != 0 {
      try visitor.visitSingularFloatField(value: self.turnerAngle, fieldNumber: 1)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 2)
    }
    if self.lightState != 0 {
      try visitor.visitSingularInt32Field(value: self.lightState, fieldNumber: 3)
    }
    if self.timeRemaining != 0 {
      try visitor.visitSingularInt32Field(value: self.timeRemaining, fieldNumber: 4)
    }
    if self.recUpperSpeed != 0 {
      try visitor.visitSingularDoubleField(value: self.recUpperSpeed, fieldNumber: 5)
    }
    if self.recFloorSpeed != 0 {
      try visitor.visitSingularDoubleField(value: self.recFloorSpeed, fieldNumber: 6)
    }
    if self.directionNodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.directionNodeID, fieldNumber: 7)
    }
    if self.phaseID != 0 {
      try visitor.visitSingularInt32Field(value: self.phaseID, fieldNumber: 8)
    }
    if self.decelRedBreak != 0 {
      try visitor.visitSingularDoubleField(value: self.decelRedBreak, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TrafficLightResult.TrafficLightResultInformation, rhs: NebulalinkProMessage_TrafficLightResult.TrafficLightResultInformation) -> Bool {
    if lhs.turnerAngle != rhs.turnerAngle {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.lightState != rhs.lightState {return false}
    if lhs.timeRemaining != rhs.timeRemaining {return false}
    if lhs.recUpperSpeed != rhs.recUpperSpeed {return false}
    if lhs.recFloorSpeed != rhs.recFloorSpeed {return false}
    if lhs.directionNodeID != rhs.directionNodeID {return false}
    if lhs.phaseID != rhs.phaseID {return false}
    if lhs.decelRedBreak != rhs.decelRedBreak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_CdasAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CdasAlert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targetList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targetList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_CdasAlert, rhs: NebulalinkProMessage_CdasAlert) -> Bool {
    if lhs.targetList != rhs.targetList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TargetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_type"),
    2: .standard(proto: "device_id"),
    3: .same(proto: "gnss"),
    4: .standard(proto: "veh_info"),
    5: .standard(proto: "lm_res"),
    6: .standard(proto: "ph_res"),
    7: .standard(proto: "pp_res"),
    8: .standard(proto: "pos_res"),
    9: .standard(proto: "td_res"),
    10: .standard(proto: "tw_res"),
  ]

  fileprivate class _StorageClass {
    var _targetType: Int32 = 0
    var _deviceID: Data = Data()
    var _gnss: NebulalinkProMessage_GnssDesc? = nil
    var _vehInfo: NebulalinkProMessage_VehicleInfoDesc? = nil
    var _lmRes: NebulalinkProMessage_LogicMapResult? = nil
    var _phRes: NebulalinkProMessage_PathHistroyResult? = nil
    var _ppRes: NebulalinkProMessage_PathPredictResult? = nil
    var _posRes: NebulalinkProMessage_PositionResult? = nil
    var _tdRes: NebulalinkProMessage_TargetDirectionDesc? = nil
    var _twRes: NebulalinkProMessage_TargetWarnDesc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetType = source._targetType
      _deviceID = source._deviceID
      _gnss = source._gnss
      _vehInfo = source._vehInfo
      _lmRes = source._lmRes
      _phRes = source._phRes
      _ppRes = source._ppRes
      _posRes = source._posRes
      _tdRes = source._tdRes
      _twRes = source._twRes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._targetType) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._deviceID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._gnss) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._vehInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lmRes) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._phRes) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._ppRes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._posRes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tdRes) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._twRes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._targetType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetType, fieldNumber: 1)
      }
      if !_storage._deviceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceID, fieldNumber: 2)
      }
      try { if let v = _storage._gnss {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._vehInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lmRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._phRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._ppRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._posRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tdRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._twRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TargetInfo, rhs: NebulalinkProMessage_TargetInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetType != rhs_storage._targetType {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._gnss != rhs_storage._gnss {return false}
        if _storage._vehInfo != rhs_storage._vehInfo {return false}
        if _storage._lmRes != rhs_storage._lmRes {return false}
        if _storage._phRes != rhs_storage._phRes {return false}
        if _storage._ppRes != rhs_storage._ppRes {return false}
        if _storage._posRes != rhs_storage._posRes {return false}
        if _storage._tdRes != rhs_storage._tdRes {return false}
        if _storage._twRes != rhs_storage._twRes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_GnssDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GnssDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "altitude"),
    4: .same(proto: "time"),
    5: .same(proto: "speed"),
    6: .same(proto: "heading"),
    7: .same(proto: "accel"),
    8: .standard(proto: "accel_angle"),
    9: .standard(proto: "acc4way_lon"),
    10: .standard(proto: "acc4way_lat"),
    11: .standard(proto: "acc4way_vert"),
    12: .standard(proto: "acc4way_yaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.accel) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.accelAngle) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.acc4WayLon) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.acc4WayLat) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.acc4WayVert) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.acc4WayYaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 4)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 5)
    }
    if self.heading != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 6)
    }
    if self.accel != 0 {
      try visitor.visitSingularFloatField(value: self.accel, fieldNumber: 7)
    }
    if self.accelAngle != 0 {
      try visitor.visitSingularFloatField(value: self.accelAngle, fieldNumber: 8)
    }
    if self.acc4WayLon != 0 {
      try visitor.visitSingularFloatField(value: self.acc4WayLon, fieldNumber: 9)
    }
    if self.acc4WayLat != 0 {
      try visitor.visitSingularFloatField(value: self.acc4WayLat, fieldNumber: 10)
    }
    if self.acc4WayVert != 0 {
      try visitor.visitSingularFloatField(value: self.acc4WayVert, fieldNumber: 11)
    }
    if self.acc4WayYaw != 0 {
      try visitor.visitSingularFloatField(value: self.acc4WayYaw, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_GnssDesc, rhs: NebulalinkProMessage_GnssDesc) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.time != rhs.time {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.accel != rhs.accel {return false}
    if lhs.accelAngle != rhs.accelAngle {return false}
    if lhs.acc4WayLon != rhs.acc4WayLon {return false}
    if lhs.acc4WayLat != rhs.acc4WayLat {return false}
    if lhs.acc4WayVert != rhs.acc4WayVert {return false}
    if lhs.acc4WayYaw != rhs.acc4WayYaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_VehicleInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "veh_num"),
    2: .standard(proto: "veh_brand"),
    3: .standard(proto: "veh_type"),
    4: .standard(proto: "fuel_type"),
    5: .same(proto: "length"),
    6: .same(proto: "width"),
    7: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.vehNum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.vehBrand) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.vehType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.fuelType) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.length) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehNum.isEmpty {
      try visitor.visitSingularBytesField(value: self.vehNum, fieldNumber: 1)
    }
    if !self.vehBrand.isEmpty {
      try visitor.visitSingularBytesField(value: self.vehBrand, fieldNumber: 2)
    }
    if self.vehType != 0 {
      try visitor.visitSingularInt32Field(value: self.vehType, fieldNumber: 3)
    }
    if self.fuelType != 0 {
      try visitor.visitSingularInt32Field(value: self.fuelType, fieldNumber: 4)
    }
    if self.length != 0 {
      try visitor.visitSingularFloatField(value: self.length, fieldNumber: 5)
    }
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 6)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_VehicleInfoDesc, rhs: NebulalinkProMessage_VehicleInfoDesc) -> Bool {
    if lhs.vehNum != rhs.vehNum {return false}
    if lhs.vehBrand != rhs.vehBrand {return false}
    if lhs.vehType != rhs.vehType {return false}
    if lhs.fuelType != rhs.fuelType {return false}
    if lhs.length != rhs.length {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LogicMapResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogicMapResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "same_link"),
    2: .same(proto: "opposite"),
    3: .same(proto: "intersection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: NebulalinkProMessage_SameDirectionLink?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .sameLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .sameLink(v)
        }
      }()
      case 2: try {
        var v: NebulalinkProMessage_OppositeDirectionLink?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .opposite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .opposite(v)
        }
      }()
      case 3: try {
        var v: NebulalinkProMessage_ApproachIntersection?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .intersection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .intersection(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .sameLink?: try {
      guard case .sameLink(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .opposite?: try {
      guard case .opposite(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .intersection?: try {
      guard case .intersection(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LogicMapResult, rhs: NebulalinkProMessage_LogicMapResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_SameDirectionLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SameDirectionLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node"),
    2: .standard(proto: "to_node"),
    3: .standard(proto: "lane_info"),
    4: .standard(proto: "lane_num"),
    5: .standard(proto: "lon_dis"),
    6: .standard(proto: "lat_dis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fromNode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.toNode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.laneInfo) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.laneNum) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.lonDis) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.latDis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromNode != 0 {
      try visitor.visitSingularInt64Field(value: self.fromNode, fieldNumber: 1)
    }
    if self.toNode != 0 {
      try visitor.visitSingularInt64Field(value: self.toNode, fieldNumber: 2)
    }
    if self.laneInfo != false {
      try visitor.visitSingularBoolField(value: self.laneInfo, fieldNumber: 3)
    }
    if self.laneNum != 0 {
      try visitor.visitSingularInt32Field(value: self.laneNum, fieldNumber: 4)
    }
    if self.lonDis != 0 {
      try visitor.visitSingularFloatField(value: self.lonDis, fieldNumber: 5)
    }
    if self.latDis != 0 {
      try visitor.visitSingularFloatField(value: self.latDis, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_SameDirectionLink, rhs: NebulalinkProMessage_SameDirectionLink) -> Bool {
    if lhs.fromNode != rhs.fromNode {return false}
    if lhs.toNode != rhs.toNode {return false}
    if lhs.laneInfo != rhs.laneInfo {return false}
    if lhs.laneNum != rhs.laneNum {return false}
    if lhs.lonDis != rhs.lonDis {return false}
    if lhs.latDis != rhs.latDis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_OppositeDirectionLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OppositeDirectionLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node"),
    2: .standard(proto: "to_node"),
    3: .standard(proto: "lane_info"),
    4: .standard(proto: "lane_num"),
    5: .standard(proto: "lon_dis"),
    6: .standard(proto: "lat_dis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fromNode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.toNode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.laneInfo) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.laneNum) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.lonDis) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.latDis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromNode != 0 {
      try visitor.visitSingularInt64Field(value: self.fromNode, fieldNumber: 1)
    }
    if self.toNode != 0 {
      try visitor.visitSingularInt64Field(value: self.toNode, fieldNumber: 2)
    }
    if self.laneInfo != false {
      try visitor.visitSingularBoolField(value: self.laneInfo, fieldNumber: 3)
    }
    if self.laneNum != 0 {
      try visitor.visitSingularInt32Field(value: self.laneNum, fieldNumber: 4)
    }
    if self.lonDis != 0 {
      try visitor.visitSingularFloatField(value: self.lonDis, fieldNumber: 5)
    }
    if self.latDis != 0 {
      try visitor.visitSingularFloatField(value: self.latDis, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_OppositeDirectionLink, rhs: NebulalinkProMessage_OppositeDirectionLink) -> Bool {
    if lhs.fromNode != rhs.fromNode {return false}
    if lhs.toNode != rhs.toNode {return false}
    if lhs.laneInfo != rhs.laneInfo {return false}
    if lhs.laneNum != rhs.laneNum {return false}
    if lhs.lonDis != rhs.lonDis {return false}
    if lhs.latDis != rhs.latDis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_ApproachIntersection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApproachIntersection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node"),
    2: .standard(proto: "to_node"),
    3: .standard(proto: "remote_node"),
    4: .standard(proto: "hv_dis"),
    5: .standard(proto: "rv_dis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fromNode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.toNode) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.remoteNode) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.hvDis) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.rvDis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromNode != 0 {
      try visitor.visitSingularInt64Field(value: self.fromNode, fieldNumber: 1)
    }
    if self.toNode != 0 {
      try visitor.visitSingularInt64Field(value: self.toNode, fieldNumber: 2)
    }
    if self.remoteNode != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteNode, fieldNumber: 3)
    }
    if self.hvDis != 0 {
      try visitor.visitSingularFloatField(value: self.hvDis, fieldNumber: 4)
    }
    if self.rvDis != 0 {
      try visitor.visitSingularFloatField(value: self.rvDis, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_ApproachIntersection, rhs: NebulalinkProMessage_ApproachIntersection) -> Bool {
    if lhs.fromNode != rhs.fromNode {return false}
    if lhs.toNode != rhs.toNode {return false}
    if lhs.remoteNode != rhs.remoteNode {return false}
    if lhs.hvDis != rhs.hvDis {return false}
    if lhs.rvDis != rhs.rvDis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PathHistroyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathHistroyResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "lon_dis"),
    3: .standard(proto: "lat_dis"),
    4: .standard(proto: "head_diff"),
    5: .standard(proto: "time_dis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.lonDis) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.latDis) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.headDiff) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.timeDis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if self.lonDis != 0 {
      try visitor.visitSingularFloatField(value: self.lonDis, fieldNumber: 2)
    }
    if self.latDis != 0 {
      try visitor.visitSingularFloatField(value: self.latDis, fieldNumber: 3)
    }
    if self.headDiff != 0 {
      try visitor.visitSingularFloatField(value: self.headDiff, fieldNumber: 4)
    }
    if self.timeDis != 0 {
      try visitor.visitSingularFloatField(value: self.timeDis, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PathHistroyResult, rhs: NebulalinkProMessage_PathHistroyResult) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.lonDis != rhs.lonDis {return false}
    if lhs.latDis != rhs.latDis {return false}
    if lhs.headDiff != rhs.headDiff {return false}
    if lhs.timeDis != rhs.timeDis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PathPredictResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathPredictResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "lon_dis"),
    3: .standard(proto: "lat_dis"),
    4: .standard(proto: "hv_node_dis"),
    5: .standard(proto: "rv_node_dis"),
    6: .standard(proto: "head_diff"),
    7: .standard(proto: "time_dis"),
    8: .standard(proto: "node_time_dis"),
    9: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.lonDis) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.latDis) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.hvNodeDis) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.rvNodeDis) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.headDiff) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.timeDis) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.nodeTimeDis) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if self.lonDis != 0 {
      try visitor.visitSingularFloatField(value: self.lonDis, fieldNumber: 2)
    }
    if self.latDis != 0 {
      try visitor.visitSingularFloatField(value: self.latDis, fieldNumber: 3)
    }
    if self.hvNodeDis != 0 {
      try visitor.visitSingularFloatField(value: self.hvNodeDis, fieldNumber: 4)
    }
    if self.rvNodeDis != 0 {
      try visitor.visitSingularFloatField(value: self.rvNodeDis, fieldNumber: 5)
    }
    if self.headDiff != 0 {
      try visitor.visitSingularFloatField(value: self.headDiff, fieldNumber: 6)
    }
    if self.timeDis != 0 {
      try visitor.visitSingularFloatField(value: self.timeDis, fieldNumber: 7)
    }
    if self.nodeTimeDis != 0 {
      try visitor.visitSingularFloatField(value: self.nodeTimeDis, fieldNumber: 8)
    }
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PathPredictResult, rhs: NebulalinkProMessage_PathPredictResult) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.lonDis != rhs.lonDis {return false}
    if lhs.latDis != rhs.latDis {return false}
    if lhs.hvNodeDis != rhs.hvNodeDis {return false}
    if lhs.rvNodeDis != rhs.rvNodeDis {return false}
    if lhs.headDiff != rhs.headDiff {return false}
    if lhs.timeDis != rhs.timeDis {return false}
    if lhs.nodeTimeDis != rhs.nodeTimeDis {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_PositionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "angle"),
    2: .same(proto: "distance"),
    3: .standard(proto: "lon_dis"),
    4: .standard(proto: "lat_dis"),
    5: .standard(proto: "dir_diff"),
    7: .standard(proto: "hv_node_dis"),
    8: .standard(proto: "rv_node_dis"),
    9: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.angle) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.distance) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.lonDis) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.latDis) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.dirDiff) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.hvNodeDis) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.rvNodeDis) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularFloatField(value: self.angle, fieldNumber: 1)
    }
    if self.distance != 0 {
      try visitor.visitSingularFloatField(value: self.distance, fieldNumber: 2)
    }
    if self.lonDis != 0 {
      try visitor.visitSingularFloatField(value: self.lonDis, fieldNumber: 3)
    }
    if self.latDis != 0 {
      try visitor.visitSingularFloatField(value: self.latDis, fieldNumber: 4)
    }
    if self.dirDiff != 0 {
      try visitor.visitSingularFloatField(value: self.dirDiff, fieldNumber: 5)
    }
    if self.hvNodeDis != 0 {
      try visitor.visitSingularFloatField(value: self.hvNodeDis, fieldNumber: 7)
    }
    if self.rvNodeDis != 0 {
      try visitor.visitSingularFloatField(value: self.rvNodeDis, fieldNumber: 8)
    }
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_PositionResult, rhs: NebulalinkProMessage_PositionResult) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.lonDis != rhs.lonDis {return false}
    if lhs.latDis != rhs.latDis {return false}
    if lhs.dirDiff != rhs.dirDiff {return false}
    if lhs.hvNodeDis != rhs.hvNodeDis {return false}
    if lhs.rvNodeDis != rhs.rvNodeDis {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TargetDirectionDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetDirectionDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TargetDirectionDesc, rhs: NebulalinkProMessage_TargetDirectionDesc) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TargetWarnDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetWarnDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tw_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.twInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.twInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.twInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TargetWarnDesc, rhs: NebulalinkProMessage_TargetWarnDesc) -> Bool {
    if lhs.twInfo != rhs.twInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_TargetWarnInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetWarnInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fcw"),
    2: .same(proto: "icw"),
    3: .same(proto: "clw"),
    4: .same(proto: "avw"),
    5: .same(proto: "ebw"),
    6: .same(proto: "dnpw"),
    7: .same(proto: "lcw"),
    8: .same(proto: "lta"),
    9: .same(proto: "evw"),
    10: .same(proto: "fvw"),
    11: .same(proto: "bsw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: NebulalinkProMessage_FCWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .fcw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .fcw(v)
        }
      }()
      case 2: try {
        var v: NebulalinkProMessage_ICWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .icw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .icw(v)
        }
      }()
      case 3: try {
        var v: NebulalinkProMessage_CLWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .clw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .clw(v)
        }
      }()
      case 4: try {
        var v: NebulalinkProMessage_AVWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .avw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .avw(v)
        }
      }()
      case 5: try {
        var v: NebulalinkProMessage_EBWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .ebw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .ebw(v)
        }
      }()
      case 6: try {
        var v: NebulalinkProMessage_DNPWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .dnpw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .dnpw(v)
        }
      }()
      case 7: try {
        var v: NebulalinkProMessage_LCWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .lcw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .lcw(v)
        }
      }()
      case 8: try {
        var v: NebulalinkProMessage_LTAInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .lta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .lta(v)
        }
      }()
      case 9: try {
        var v: NebulalinkProMessage_EVWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .evw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .evw(v)
        }
      }()
      case 10: try {
        var v: NebulalinkProMessage_FVWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .fvw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .fvw(v)
        }
      }()
      case 11: try {
        var v: NebulalinkProMessage_BSWInfoDesc?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .bsw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .bsw(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.choice {
    case .fcw?: try {
      guard case .fcw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .icw?: try {
      guard case .icw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .clw?: try {
      guard case .clw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .avw?: try {
      guard case .avw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .ebw?: try {
      guard case .ebw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dnpw?: try {
      guard case .dnpw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .lcw?: try {
      guard case .lcw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .lta?: try {
      guard case .lta(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .evw?: try {
      guard case .evw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .fvw?: try {
      guard case .fvw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .bsw?: try {
      guard case .bsw(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_TargetWarnInfo, rhs: NebulalinkProMessage_TargetWarnInfo) -> Bool {
    if lhs.choice != rhs.choice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_FCWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FCWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_FCWInfoDesc, rhs: NebulalinkProMessage_FCWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_ICWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "d_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.dTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.dTime != 0 {
      try visitor.visitSingularFloatField(value: self.dTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_ICWInfoDesc, rhs: NebulalinkProMessage_ICWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.dTime != rhs.dTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_CLWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CLWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_CLWInfoDesc, rhs: NebulalinkProMessage_CLWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_AVWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AVWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_AVWInfoDesc, rhs: NebulalinkProMessage_AVWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_EBWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EBWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_EBWInfoDesc, rhs: NebulalinkProMessage_EBWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_DNPWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DNPWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .same(proto: "subtype"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 3)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_DNPWInfoDesc, rhs: NebulalinkProMessage_DNPWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LCWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LCWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LCWInfoDesc, rhs: NebulalinkProMessage_LCWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_LTAInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LTAInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "d_time"),
    3: .same(proto: "subtype"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.dTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.dTime != 0 {
      try visitor.visitSingularFloatField(value: self.dTime, fieldNumber: 2)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 3)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_LTAInfoDesc, rhs: NebulalinkProMessage_LTAInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.dTime != rhs.dTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_EVWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EVWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_EVWInfoDesc, rhs: NebulalinkProMessage_EVWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_FVWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FVWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "h_time"),
    3: .same(proto: "subtype"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 2)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 3)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_FVWInfoDesc, rhs: NebulalinkProMessage_FVWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_BSWInfoDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BSWInfoDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confidence"),
    2: .standard(proto: "c_time"),
    3: .standard(proto: "h_time"),
    4: .same(proto: "subtype"),
    5: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confidence) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cTime) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.hTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.subtype) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidence != 0 {
      try visitor.visitSingularInt32Field(value: self.confidence, fieldNumber: 1)
    }
    if self.cTime != 0 {
      try visitor.visitSingularFloatField(value: self.cTime, fieldNumber: 2)
    }
    if self.hTime != 0 {
      try visitor.visitSingularFloatField(value: self.hTime, fieldNumber: 3)
    }
    if self.subtype != 0 {
      try visitor.visitSingularInt32Field(value: self.subtype, fieldNumber: 4)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_BSWInfoDesc, rhs: NebulalinkProMessage_BSWInfoDesc) -> Bool {
    if lhs.confidence != rhs.confidence {return false}
    if lhs.cTime != rhs.cTime {return false}
    if lhs.hTime != rhs.hTime {return false}
    if lhs.subtype != rhs.subtype {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConfigurationInformationValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configurationInformationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configurationInformationValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configurationInformationValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_Configuration, rhs: NebulalinkProMessage_Configuration) -> Bool {
    if lhs.configurationInformationValue != rhs.configurationInformationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NebulalinkProMessage_Configuration.ConfigurationInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = NebulalinkProMessage_Configuration.protoMessageName + ".ConfigurationInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_name"),
    2: .standard(proto: "config_type"),
    3: .standard(proto: "config_value_int"),
    4: .standard(proto: "config_value_string"),
    5: .standard(proto: "config_value_double"),
    6: .standard(proto: "key_length"),
    7: .standard(proto: "value_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.configName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.configType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.configValueInt) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.configValueString) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.configValueDouble) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.keyLength) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.valueLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configName.isEmpty {
      try visitor.visitSingularBytesField(value: self.configName, fieldNumber: 1)
    }
    if self.configType != 0 {
      try visitor.visitSingularInt32Field(value: self.configType, fieldNumber: 2)
    }
    if self.configValueInt != 0 {
      try visitor.visitSingularInt32Field(value: self.configValueInt, fieldNumber: 3)
    }
    if !self.configValueString.isEmpty {
      try visitor.visitSingularBytesField(value: self.configValueString, fieldNumber: 4)
    }
    if self.configValueDouble != 0 {
      try visitor.visitSingularDoubleField(value: self.configValueDouble, fieldNumber: 5)
    }
    if self.keyLength != 0 {
      try visitor.visitSingularInt32Field(value: self.keyLength, fieldNumber: 6)
    }
    if self.valueLength != 0 {
      try visitor.visitSingularInt32Field(value: self.valueLength, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NebulalinkProMessage_Configuration.ConfigurationInformation, rhs: NebulalinkProMessage_Configuration.ConfigurationInformation) -> Bool {
    if lhs.configName != rhs.configName {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.configValueInt != rhs.configValueInt {return false}
    if lhs.configValueString != rhs.configValueString {return false}
    if lhs.configValueDouble != rhs.configValueDouble {return false}
    if lhs.keyLength != rhs.keyLength {return false}
    if lhs.valueLength != rhs.valueLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
